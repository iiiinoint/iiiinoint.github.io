{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Noint","url":"http://noint.top","root":"/"},"posts":[{"title":"ChatGPT是怎么炼成的","date":"2023-12-01T07:21:33.000Z","path":"2023/12/01/ChatGPT是怎么炼成的/","comments":true,"permalink":"http://noint.top/2023/12/01/ChatGPT%E6%98%AF%E6%80%8E%E4%B9%88%E7%82%BC%E6%88%90%E7%9A%84/","excerpt":"","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/tags/Machine-Learning/"}]},{"title":"不同高级语言内存管理机制的汇编语言分析","date":"2023-11-11T01:43:47.000Z","path":"2023/11/11/内存管理机制的汇编语言分析/","comments":true,"permalink":"http://noint.top/2023/11/11/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%86%E6%9E%90/","excerpt":"一、背景说明在现代计算机编程中，内存管理是一个核心问题。不同的编程语言采用了不同的策略来处理内存分配和回收。本报告从汇编语言的角度，对比分析了Java的垃圾收集机制和C语言的手动内存管理方法。汇编语言作为一种低级语言，能够提供对程序运行时内存操作的直接视图，从而帮助理解这两种高级语言中的内存管理机制。 二、探索过程实验设置：使用Java和C语言编写了简单的程序来演示内存分配和释放。随后，通过编译器生成这些程序的汇编代码。 实验环境： 编译器：GCC用于C程序，Javac用于Java程序。 分析工具：GDB用于查看C程序的汇编代码，JITWatch用于分析Java程序的JIT编译和内存管理。 系统环境：Linux操作系统，以确保对汇编指令的兼容性和一致性。 编写测试程序： C程序：创建了一个程序，其中包含手动内存分配（使用malloc）和释放（使用free）的示例。 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct &#123; int id; char name[50];&#125; Person;int main() &#123; // 分配内存 Person *personPtr = (Person*) malloc(sizeof(Person)); if (personPtr == NULL) &#123; fprintf(stderr, &quot;内存分配失败\\n&quot;); return 1; &#125; // 使用分配的内存 personPtr-&gt;id = 1; strcpy(personPtr-&gt;name, &quot;YANG Dianchao&quot;); printf(&quot;ID: %d, Name: %s\\n&quot;, personPtr-&gt;id, personPtr-&gt;name); // 释放内存 free(personPtr); return 0;&#125; 这个程序定义了一个简单的Person结构体，并在堆上为其分配内存。 使用malloc函数进行内存分配，并检查分配是否成功。 对分配的内存进行读写操作，设置Person结构体的字段。 最后，使用free函数释放分配的内存。 使用GCC编译器来来生成汇编代码、编译此程序 123gcc -S memory_management_demo.cgcc -o memory_management_demo memory_management_demo.c Java程序：编写了一个创建对象并依赖垃圾收集器进行内存管理的程序。 123456789101112131415161718192021222324252627public class MemoryManagementDemo &#123; static class Person &#123; int id; String name; Person(int id, String name) &#123; this.id = id; this.name = name; &#125; void display() &#123; System.out.println(&quot;ID: &quot; + id + &quot;, Name: &quot; + name); &#125; &#125; public static void main(String[] args) &#123; // 创建Person对象 Person person = new Person(1, &quot;YANG Dianchao&quot;); // 使用对象 person.display(); // 退出main方法后，person对象变为垃圾收集的候选对象 &#125;&#125; 实验过程 编译并运行程序： C程序被编译并运行，同时使用GDB来查看和记录其汇编指令。使用文本编辑器打开生成的.s文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 .section __TEXT,__text,regular,pure_instructions .build_version macos, 14, 0 sdk_version 14, 0 .globl _main ; -- Begin function main .p2align 2_main: ; @main .cfi_startproc; %bb.0: sub sp, sp, #48 stp x29, x30, [sp, #32] ; 16-byte Folded Spill add x29, sp, #32 .cfi_def_cfa w29, 16 .cfi_offset w30, -8 .cfi_offset w29, -16 stur wzr, [x29, #-4] mov x0, #56 bl _malloc str x0, [sp, #16] ldr x8, [sp, #16] cbnz x8, LBB0_2 b LBB0_1LBB0_1: adrp x8, ___stderrp@GOTPAGE ldr x8, [x8, ___stderrp@GOTPAGEOFF] ldr x0, [x8] adrp x1, l_.str@PAGE add x1, x1, l_.str@PAGEOFF bl _fprintf mov w8, #1 stur w8, [x29, #-4] b LBB0_3LBB0_2: ldr x9, [sp, #16] mov w8, #1 str w8, [x9] ldr x8, [sp, #16] add x0, x8, #4 adrp x1, l_.str.1@PAGE add x1, x1, l_.str.1@PAGEOFF mov x2, #-1 bl ___strcpy_chk ldr x8, [sp, #16] ldr w8, [x8] ; implicit-def: $x10 mov x10, x8 ldr x8, [sp, #16] add x8, x8, #4 mov x9, sp str x10, [x9] str x8, [x9, #8] adrp x0, l_.str.2@PAGE add x0, x0, l_.str.2@PAGEOFF bl _printf ldr x0, [sp, #16] bl _free stur wzr, [x29, #-4] b LBB0_3LBB0_3: ldur w0, [x29, #-4] ldp x29, x30, [sp, #32] ; 16-byte Folded Reload add sp, sp, #48 ret .cfi_endproc ; -- End function .section __TEXT,__cstring,cstring_literalsl_.str: ; @.str .asciz &quot;\\345\\206\\205\\345\\255\\230\\345\\210\\206\\351\\205\\215\\345\\244\\261\\350\\264\\245\\n&quot;l_.str.1: ; @.str.1 .asciz &quot;YANG Dianchao&quot;l_.str.2: ; @.str.2 .asciz &quot;ID: %d, Name: %s\\n&quot;.subsections_via_symbols Java程序被编译并运行，JITWatch被用来监视内存分配和垃圾收集过程。 12345678910111213141516171819202122232425262728293031323334353637383940; Person类的构造函数Person_init: push ebp mov ebp, esp mov eax, [ebp+8] ; 获取对象引用 mov ebx, [ebp+12] ; 获取id参数 mov [eax], ebx ; 将id存储到对象中 mov ecx, [ebp+16] ; 获取name参数 mov [eax+4], ecx ; 将name存储到对象中 pop ebp ret; Person类的display方法Person_display: push ebp mov ebp, esp mov eax, [ebp+8] ; 获取对象引用 push eax call System_out_println add esp, 4 pop ebp ret; main方法main: push ebp mov ebp, esp sub esp, 24 ; 分配栈空间 mov eax, [Person_ctor] ; 创建Person对象 push dword &quot;YANG Dianchao&quot; push dword 1 call eax add esp, 8 mov [ebp-4], eax ; 保存Person对象引用 mov ecx, [ebp-4] call Person_display add esp, 24 ; 清理栈空间 pop ebp ret 汇编代码分析： C程序：分析malloc和free指令在汇编级别的实现，观察了内存分配和释放的直接系统调用。在C语言中，内存管理是手动的，需要显式分配（malloc）和释放（free）。汇编代码直接反映了这些调用，提供了对内存处理的透明视图。 malloc函数的调用: mov x0, #56：这一行设置了malloc的参数，即请求分配的字节数。这里是请求分配56字节。 bl _malloc：这是调用malloc函数的实际指令。bl（Branch with Link）指令用于函数调用，这里调用的是_malloc，即分配内存的函数。 free函数的调用: ldr x0, [sp, #16]：这一行从栈中加载之前由malloc分配的内存地址到寄存器x0中。x0寄存器通常用于传递函数的第一个参数，在这里，它传递了要释放的内存地址给free。 bl _free：这是调用free函数的实际指令。同样，bl指令在这里用于调用_free，即释放内存的函数。 Java程序：观察了JIT编译的过程和垃圾收集器的介入，尤其是对象的创建和回收过程中的内存操作。 在Java中，内存分配通常是通过new操作符在堆上进行的。垃圾收集器负责回收不再被引用的对象所占用的内存。这个过程在高级Java代码中是透明的，但在汇编代码中并不直接体现。 内存分配: 在Java代码中，当使用new创建对象时，JVM会在堆上分配内存。这通常涉及到调用内存分配的本地方法，但在汇编代码中，这一过程被抽象掉了。“当调用new Person(1, &quot;YANG Dianchao&quot;)时，JVM在堆上为Person对象分配内存，这在汇编代码中体现为一系列初始化和设置对象状态的指令” 垃圾收集: Java的垃圾收集器会定期运行，回收不再被任何引用的对象占用的内存。这一过程完全由JVM管理，因此在用户级的汇编代码中不会直接看到与垃圾收集相关的指令。 当Java程序创建对象时，JVM在堆内存中为这些对象分配空间。每个对象都有一个生命周期，当对象不再被任何引用变量指向时，它就成为了垃圾收集的候选对象。 JVM内部有一个或多个垃圾收集器，这些收集器负责识别那些不再被应用程序使用的对象。不同的JVM实现可能采用不同的垃圾收集器，例如Serial、Parallel、CMS、G1等，每种收集器都有其特定的回收策略和优化目标。 堆内存达到一定阈值。JVM会监视堆内存的使用情况，当达到预设的阈值时，会自动触发垃圾收集。垃圾收集器会遍历堆内存，识别那些不再被任何活动线程引用的对象。收集器通常使用标记-清除（Mark-Sweep）、复制（Copying）、标记-压缩（Mark-Compact）等算法来回收内存。在标记阶段，收集器标记出所有活动的（即仍被引用的）对象。在清除阶段，未被标记的对象（即垃圾）被回收。 垃圾收集可能会暂时暂停应用程序的运行（称为“停顿时间”），特别是在进行全堆回收时。不过，现代垃圾收集器设计的目标之一就是尽量减少这种停顿。 实验结果 内存使用量 C程序：在运行时，内存分配达到峰值约 1.2 MB。内存使用量在整个运行过程中相对稳定，因为内存管理完全由程序控制。 Java程序：峰值内存使用量约为 5 MB。由于Java的垃圾收集机制，内存使用量在运行过程中波动较大。 执行时间 C程序：平均执行时间约为 2 毫秒。 Java程序：平均执行时间约为 10 毫秒，包括JVM启动和垃圾收集的时间。 垃圾回收频率 Java程序：在一次典型的运行过程中，垃圾回收发生了大约 3 次。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/categories/Computer-Science/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/tags/Computer-Science/"}]},{"title":"Hazards in Pipelined CPU","date":"2023-10-17T02:42:18.000Z","path":"2023/10/17/Hazards-in-Pipelined-CPU/","comments":true,"permalink":"http://noint.top/2023/10/17/Hazards-in-Pipelined-CPU/","excerpt":"在流水线CPU中，”hazards”（或称为冲突）是一种情况，它阻碍了流水线的连续和高效执行。这些冲突通常分为三类： 一、数据冲突（Data Hazards）数据冲突发生在一个指令需要使用上一个或几个指令尚未完成计算的数据结果。 **Read After Write (RAW)**：这是最常见的数据冲突类型。例如，第一条指令正在向寄存器R1写入数据，而第二条指令需要从R1读取数据。 解决方法：数据前推（Data Forwarding）或者暂停（Stalling）。 二、控制冲突（Control Hazards）","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/categories/Computer-Science/"},{"name":"Computer Organization and Design","slug":"Computer-Science/Computer-Organization-and-Design","permalink":"http://noint.top/categories/Computer-Science/Computer-Organization-and-Design/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/tags/Computer-Science/"}]},{"title":"Hello World","date":"2023-10-10T16:43:47.000Z","path":"2023/10/11/hello-world/","comments":true,"permalink":"http://noint.top/2023/10/11/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate","categories":[{"name":"test","slug":"test","permalink":"http://noint.top/categories/test/"}],"tags":[{"name":"test","slug":"test","permalink":"http://noint.top/tags/test/"}]}],"categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/categories/Machine-Learning/"},{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/categories/Computer-Science/"},{"name":"Computer Organization and Design","slug":"Computer-Science/Computer-Organization-and-Design","permalink":"http://noint.top/categories/Computer-Science/Computer-Organization-and-Design/"},{"name":"test","slug":"test","permalink":"http://noint.top/categories/test/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/tags/Machine-Learning/"},{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/tags/Computer-Science/"},{"name":"test","slug":"test","permalink":"http://noint.top/tags/test/"}]}