{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Noint","url":"http://noint.top","root":"/"},"posts":[{"title":"ChatGPT是怎么炼成的","date":"2023-12-01T07:21:33.000Z","path":"2023/12/01/ChatGPT是怎么炼成的/","comments":true,"permalink":"http://noint.top/2023/12/01/ChatGPT%E6%98%AF%E6%80%8E%E4%B9%88%E7%82%BC%E6%88%90%E7%9A%84/","excerpt":"引言在人工智能领域，ChatGPT的出现标志着一个新时代的开始。作为一个基于大规模语言模型的聊天机器人，ChatGPT不仅改变了人们与技术的交互方式，还推动了AI技术的边界。本文旨在探讨ChatGPT的主要原理、发展历史，以及它可能对社会产生的影响和带来的新研究问题。 ChatGPT的主要原理ChatGPT的核心基于GPT（Generative Pre-trained Transformer）架构，这是一种革命性的自然语言处理技术。要理解ChatGPT的工作原理，我们需要从以下几个方面来深入探讨： Transformer架构Transformer是一种专为处理序列数据而设计的深度学习模型架构。它在2017年由Google的研究者提出，并迅速成为自然语言处理领域的标准。Transformer的核心特点是其使用了自注意力（Self-Attention）机制。这个机制使模型能够在处理一个单词时，同时考虑到句子中的其他单词，从而更好地理解上下文。 自注意力机制的数学原理 输入表示：Transformer接收一系列向量作为输入，这些向量通常是输入序列中每个元素（如单词）的嵌入表示。 查询、键和值：自注意力机制涉及三组权重矩阵——查询（Q）、键（K）和值（V）。这些矩阵是通过训练学习得到的。对于每个输入向量，模型使用这些权重矩阵分别计算查询、键和值。 注意力分数：模型计算查询和所有键之间的点积，以得出注意力分数。这个分数决定了在生成输出时应该给予每个值多少权重。 缩放点积注意力：为了避免在计算点积时数值过大，会将注意力分数除以键的维度的平方根，然后应用softmax函数来标准化分数。 输出计算：最后，这些分数与值相乘，然后相加，生成最终的输出向量。 层归一化和位置编码除了自注意力机制，Transformer还使用了层归一化（Layer Normalization）和位置编码（Positional Encoding）来进一步提升性能。 层归一化：这是一种标准化技术，用于稳定深度神经网络的训练过程。 位置编码：由于Transformer本身不处理序列的顺序信息，位置编码被加入到输入嵌入中，以提供序列中各元素的位置信息。 预训练和微调1. 预训练","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/tags/Machine-Learning/"}]},{"title":"不同高级语言内存管理机制的汇编语言分析","date":"2023-11-11T01:43:47.000Z","path":"2023/11/11/内存管理机制的汇编语言分析/","comments":true,"permalink":"http://noint.top/2023/11/11/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%86%E6%9E%90/","excerpt":"一、背景说明在现代计算机编程中，内存管理是一个核心问题。不同的编程语言采用了不同的策略来处理内存分配和回收。本报告从汇编语言的角度，对比分析了Java的垃圾收集机制和C语言的手动内存管理方法。汇编语言作为一种低级语言，能够提供对程序运行时内存操作的直接视图，从而帮助理解这两种高级语言中的内存管理机制。 二、探索过程实验设置：使用Java和C语言编写了简单的程序来演示内存分配和释放。随后，通过编译器生成这些程序的汇编代码。 实验环境： 编译器：GCC用于C程序，Javac用于Java程序。 分析工具：GDB用于查看C程序的汇编代码，JITWatch用于分析Java程序的JIT编译和内存管理。 系统环境：Linux操作系统，以确保对汇编指令的兼容性和一致性。 编写测试程序： C程序：创建了一个程序，其中包含手动内存分配（使用malloc）和释放（使用free）的示例。 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct &#123; int id; char name[50];&#125; Person;int main() &#123; // 分配内存 Person *personPtr = (Person*) malloc(sizeof(Person)); if (personPtr == NULL) &#123; fprintf(stderr, &quot;内存分配失败\\n&quot;); return 1; &#125; // 使用分配的内存 personPtr-&gt;id = 1; strcpy(personPtr-&gt;name, &quot;YANG Dianchao&quot;); printf(&quot;ID: %d, Name: %s\\n&quot;, personPtr-&gt;id, personPtr-&gt;name); // 释放内存 free(personPtr); return 0;&#125; 这个程序定义了一个简单的Person结构体，并在堆上为其分配内存。 使用malloc函数进行内存分配，并检查分配是否成功。 对分配的内存进行读写操作，设置Person结构体的字段。 最后，使用free函数释放分配的内存。 使用GCC编译器来来生成汇编代码、编译此程序 123gcc -S memory_management_demo.cgcc -o memory_management_demo memory_management_demo.c Java程序：编写了一个创建对象并依赖垃圾收集器进行内存管理的程序。 123456789101112131415161718192021222324252627public class MemoryManagementDemo &#123; static class Person &#123; int id; String name; Person(int id, String name) &#123; this.id = id; this.name = name; &#125; void display() &#123; System.out.println(&quot;ID: &quot; + id + &quot;, Name: &quot; + name); &#125; &#125; public static void main(String[] args) &#123; // 创建Person对象 Person person = new Person(1, &quot;YANG Dianchao&quot;); // 使用对象 person.display(); // 退出main方法后，person对象变为垃圾收集的候选对象 &#125;&#125;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/categories/Computer-Science/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/tags/Computer-Science/"}]},{"title":"Hazards in Pipelined CPU","date":"2023-10-17T02:42:18.000Z","path":"2023/10/17/Hazards-in-Pipelined-CPU/","comments":true,"permalink":"http://noint.top/2023/10/17/Hazards-in-Pipelined-CPU/","excerpt":"在流水线CPU中，”hazards”（或称为冲突）是一种情况，它阻碍了流水线的连续和高效执行。这些冲突通常分为三类： 一、数据冲突（Data Hazards）数据冲突发生在一个指令需要使用上一个或几个指令尚未完成计算的数据结果。 **Read After Write (RAW)**：这是最常见的数据冲突类型。例如，第一条指令正在向寄存器R1写入数据，而第二条指令需要从R1读取数据。 解决方法：数据前推（Data Forwarding）或者暂停（Stalling）。 二、控制冲突（Control Hazards）","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/categories/Computer-Science/"},{"name":"Computer Organization and Design","slug":"Computer-Science/Computer-Organization-and-Design","permalink":"http://noint.top/categories/Computer-Science/Computer-Organization-and-Design/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/tags/Computer-Science/"}]},{"title":"Hello World","date":"2023-10-10T16:43:47.000Z","path":"2023/10/11/hello-world/","comments":true,"permalink":"http://noint.top/2023/10/11/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate","categories":[],"tags":[]}],"categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/categories/Machine-Learning/"},{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/categories/Computer-Science/"},{"name":"Computer Organization and Design","slug":"Computer-Science/Computer-Organization-and-Design","permalink":"http://noint.top/categories/Computer-Science/Computer-Organization-and-Design/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/tags/Machine-Learning/"},{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/tags/Computer-Science/"}]}