{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Noint","url":"http://noint.top","root":"/"},"posts":[{"title":"HTML基本知识","date":"2024-01-27T08:18:35.000Z","path":"2024/01/27/HTML基本知识/","comments":true,"permalink":"http://noint.top/2024/01/27/HTML%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/","excerpt":"前端开发简介前端开发主要关注于创建网页和应用程序的用户界面。它包括展示给用户的所有内容和元素，如文本、图像、滑块以及交互式元素。前端开发的核心技术包括HTML、CSS和JavaScript，它们共同作用于浏览器中，提供丰富的用户体验。 1.1 HTML基础HTML（超文本标记语言）是网页的骨架。它用于结构化信息，如定义段落、标题和链接。 示例代码： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;我的网页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;欢迎来到我的网站&lt;/h1&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;a href=&quot;https://www.zju.edu.cn&quot;&gt;访问浙江大学&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 这段代码展示了一个简单的HTML结构，包括头部（head）、标题（title）、正文（body）、标题标签（h1）、段落标签（p）和链接（a）。 1.2 CSS基础CSS（层叠样式表）用于设计和美化HTML元素。通过CSS，可以调整字体、颜色、间距和布局等。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/categories/Computer-Science/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/tags/Computer-Science/"}]},{"title":"Swift语言学习笔记","date":"2024-01-26T13:50:23.000Z","path":"2024/01/26/Swift语言学习笔记/","comments":true,"permalink":"http://noint.top/2024/01/26/Swift%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"关于 SwiftSwift 是一种非常好的编写软件的方式，无论是手机，台式机，服务器，还是其他运行代码的设备。它是一种安全，快速和互动的编程语言，将现代编程语言的精华和苹果工程师文化的智慧，以及来自开源社区的多样化贡献结合了起来。编译器对性能进行了优化，编程语言对开发进行了优化，两者互不干扰，鱼与熊掌兼得。 Swift 对于初学者来说也很友好。它是一门满足工业标准的编程语言，但又有着脚本语言般的表达力和可玩性。它支持代码预览（playgrounds），这个革命性的特性可以允许程序员在不编译和运行应用程序的前提下运行 Swift 代码并实时查看结果。 Swift 通过采用现代编程模式来避免大量常见编程错误： 变量始终在使用前初始化。 检查数组索引超出范围的错误。 检查整数是否溢出。 可选值确保明确处理 nil 值。 内存被自动管理。 错误处理允许从意外故障控制恢复。 Swift 代码被编译和优化，以充分利用现代硬件。语法和标准库是基于指导原则设计的，编写代码的明显方式也应该是最好的。安全性和速度的结合使得 Swift 成为从 “Hello，world！” 到整个操作系统的绝佳选择。 关于语法细节可参考：https://swift.bootcss.com/ 语法笔记2.1 说明Swift 包含了 C 和 Objective-C 上所有基础数据类型，Int 表示整型值； Double 和 Float 表示浮点型值； Bool 是布尔型值；String 是文本型数据。 Swift 还提供了三个基本的集合类型，Array、Set 和 Dictionary。 就像 C 语言一样，Swift 使用变量来进行存储并通过变量名来关联值。在 Swift 中，广泛的使用着值不可变的变量，它们就是常量，而且比 C 语言的常量更强大。在 Swift 中，如果你要处理的值不需要改变，那使用常量可以让你的代码更加安全并且更清晰地表达你的意图。 除了我们熟悉的类型，Swift 还增加了 Objective-C 中没有的高阶数据类型比如元组（Tuple）。元组可以让你创建或者传递一组数据，比如作为函数的返回值时，你可以用一个元组可以返回多个值。 Swift 还增加了可选（Optional）类型，用于处理值缺失的情况。可选表示 “那儿有一个值，并且它等于 x ” 或者 “那儿没有值” 。可选有点像在 Objective-C 中使用 nil ，但是它可以用在任何类型上，不仅仅是类。可选类型比 Objective-C 中的 nil 指针更加安全也更具表现力，它是 Swift 许多强大特性的重要组成部分。 Swift 是一门 类型安全 的语言，这意味着 Swift 可以让你清楚地知道值的类型。如果你的代码需要一个 String ，类型安全会阻止你不小心传入一个 Int 。同样的，如果你的代码需要一个 String，类型安全会阻止你意外传入一个可选的 String 。类型安全可以帮助你在开发阶段尽早发现并修正错误。 2.2 基础类型1）变量与常量声明常量和变量常量和变量必须在使用前声明，用 let 来声明常量，用 var 来声明变量。下面的例子展示了如何用常量和变量来记录用户尝试登录的次数： 12let maximumNumberOfLoginAttempts = 10var currentLoginAttempt = 0 这两行代码可以被理解为： “声明一个名字是 maximumNumberOfLoginAttempts 的新常量，并给它一个值 10 。然后，声明一个名字是 currentLoginAttempt 的变量并将它的值初始化为 0 。”","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/categories/Computer-Science/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/tags/Computer-Science/"}]},{"title":"Classification","date":"2023-12-03T14:38:32.000Z","path":"2023/12/03/Classification/","comments":true,"permalink":"http://noint.top/2023/12/03/Classification/","excerpt":"引言在人工智能和统计学领域，分类分析是一种关键技术，用于识别和预测数据所属的类别。与回归分析主要处理连续变量不同，分类处理的是离散的输出标签。本文旨在探讨分类的基本概念、算法以及在现实世界的应用。 一. 分类分析简介分类分析是一种监督学习方法，旨在基于一组输入变量预测离散的输出变量（类别标签）。其目标是从数据中学习一个模型，能够准确地将新数据点分类到特定的类别中。 二. 常见分类算法1. 决策树决策树是一种简单直观的分类方法，通过一系列规则将数据分割成不同的类别。每个决策节点代表对某个属性的测试，而每个叶节点代表一个类别。 决策树的构建过程 选择最优特征：首先选择一个最优的特征作为根节点。”最优”通常是通过信息增益（在ID3算法中使用）或基尼不纯度（在CART算法中使用）来决定的。 分裂节点：基于这个特征的不同值，数据集被分裂成几个子集。每个子集接着创建一个新的节点。 递归构建：对每个子集重复以上步骤，直到所有的特征都被使用，或者每个子集都不能进一步分裂（所有的元素都属于同一个类别，或达到预设的停止条件）。 剪枝处理：为了避免过拟合，可能需要对树进行剪枝。剪枝涉及删除部分子树或节点，以简化模型。 决策树的数学原理1. 信息增益（Information Gain）信息增益是用来决定决策树中节点分裂的关键标准之一。它基于信息熵的概念。信息熵是度量样本集合纯度最常用的方法，定义如下： $$ \\text{Entropy}(S) &#x3D; -\\sum_{i&#x3D;1}^{n} p_i \\log_2 p_i $$ 其中，$S$是当前数据集，$n$是不同类别的数量，$p_i$是选择该类别的概率。熵越大，数据的不确定性越高。 信息增益计算公式如下： $$ \\text{Information Gain}(S, A) &#x3D; \\text{Entropy}(S) - \\sum_{v \\in \\text{Values}(A)} \\frac{|S_v|}{|S|} \\text{Entropy}(S_v) $$ 这里，$A$是决定进行分裂的特征，$\\text{Values}(A)$是这个特征所有可能的值，$S_v$是特征$A$上值为$v$的子集，$|S_v|$和$|S|$分别是子集和原始集合的大小。 2. 基尼不纯度（Gini Impurity）基尼不纯度是CART（分类和回归树）算法中用于决策树构建的标准。它的计算公式是： $$ \\text{Gini}(S) &#x3D; 1 - \\sum_{i&#x3D;1}^{n} p_i^2 $$ 这里，$S$代表数据集，$n$是类别的数量，$p_i$是类别$i$在数据集$S$中的相对频率。基尼不纯度反映了从集合中随机选取两个元素，它们属于不同类别的概率。 3. 决策树的分裂在每个节点，算法将选择信息增益最高（或基尼不纯度最低）的特征进行分裂。这个过程会递归地继续，直到达到停止的条件，比如树达到了最大深度，或者节点中的样本数小于预定阈值。 4. 剪枝（Pruning）为了避免过拟合，决策树可能需要剪枝。一种常见的剪枝方法是代价复杂度剪枝（Cost Complexity Pruning），其基本思想是通过一个参数$\\alpha$（复杂度参数）来平衡树的深度和训练数据上的表现。 5. 决策树的决策过程当构建好一个决策树后，对于一个新的样本，我们从根节点开始，根据其特征值走向对应的分支，直到达到叶节点。叶节点的值即为模型对该样本的预测结果。 2. 支持向量机 (SVM)支持向量机是一种强大的分类器，它通过找到一个最优的超平面来区分不同类别的数据。SVM在处理高维数据和非线性问题方面表现出色。","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/tags/Machine-Learning/"}]},{"title":"Gradient Descent","date":"2023-12-02T05:23:41.000Z","path":"2023/12/02/Gradient-Descent/","comments":true,"permalink":"http://noint.top/2023/12/02/Gradient-Descent/","excerpt":"梯度下降（Gradient Descent）是一种常用于机器学习和深度学习中的优化算法，用于最小化一个函数。这个函数通常被称为“代价函数”或“损失函数”，它衡量了模型预测值与实际值之间的差距。梯度下降的核心思想是，通过迭代的方式逐步调整参数以找到使代价函数最小化的参数值。 数学推理为了理解梯度下降，我们首先需要理解“梯度”的概念。在多变量微积分中，一个函数在某一点的梯度由该点处的偏导数构成，它指向该函数增长最快的方向。因此，梯度的反方向就是函数下降最快的方向。 假设我们有一个代价函数 $ J(\\theta) $，其中 $\\theta $是模型的参数。我们的目标是找到使 $ J(\\theta) $最小的$\\theta $值。梯度下降算法会执行以下步骤： 随机初始化参数 $\\theta $。 计算代价函数 $ J(\\theta) $ 在当前 $\\theta $ 下的梯度 $ \\nabla J(\\theta) $。 更新 $\\theta $，使其沿着梯度的反方向移动：$ \\theta :&#x3D; \\theta - \\alpha \\nabla J(\\theta) $，其中 $\\alpha $ 是学习率，控制步长大小。 重复步骤2和3，直到达到收敛条件（例如，梯度的大小足够小或迭代次数达到某个阈值）。 推理过程以一个简单的线性回归模型为例，假设我们有一个代价函数 $J(\\theta) &#x3D; \\frac{1}{2m} \\sum_{i&#x3D;1}^{m} (h_\\theta(x^{(i)}) - y^{(i)})^2 $，其中 $h_\\theta(x) &#x3D; \\theta^T x $是我们的假设函数，$ m $ 是样本数量。 我们需要计算 $J(\\theta) $ 对 $\\theta$ 的偏导数，即梯度： $$ \\nabla J(\\theta) &#x3D; \\frac{\\partial}{\\partial \\theta} J(\\theta) &#x3D; \\frac{1}{m} \\sum_{i&#x3D;1}^{m} (h_\\theta(x^{(i)}) - y^{(i)}) x^{(i)} $$ 然后，我们使用梯度下降规则更新 $\\theta$：","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/tags/Machine-Learning/"}]},{"title":"Regression Analysis","date":"2023-12-01T14:39:54.000Z","path":"2023/12/01/Regression-Analysis/","comments":true,"permalink":"http://noint.top/2023/12/01/Regression-Analysis/","excerpt":"引言在人工智能和统计学领域，回归分析是一种核心技术，它用于揭示变量之间的关系、预测未来数据点，以及在实际应用中的数据驱动决策。本文将深入探讨回归分析的基本原理、数学基础以及其在现实世界的应用。 一. 回归分析简介回归分析是一种统计方法，用于研究一个或多个自变量（解释变量）与因变量（响应变量）之间的关系。它的目标是找到一个数学模型，能够最佳地描述这种依赖关系。 二. 常见回归类型1. 线性回归线性回归是最基本的回归形式，其模型假设因变量 y 和自变量 x 之间存在线性关系，可以表示为： $$y &#x3D; \\beta_0 + \\beta_1x + \\epsilon$$ 其中，$\\beta_0$ 是截距，$\\beta_1$ 是斜率，而 $\\epsilon$ 是误差项。线性回归的核心在于找出这些系数的最佳估计，通常通过最小化残差平方和（RSS）来实现。 均方误差 (MSE): 这是线性回归中最常用的损失函数。它计算了预测值与实际值之间差的平方的平均值。公式为：$MSE &#x3D; \\frac{1}{n} \\sum_{i&#x3D;1}^{n}(y_i - \\hat{y}_i)^2$，其中 $y_i$ 是实际值，$\\hat{y}_i$ 是预测值。 绝对误差 (MAE): MAE 是另一种常见的损失函数，它计算预测值与实际值之间差的绝对值的平均。公式为：$MAE &#x3D; \\frac{1}{n} \\sum_{i&#x3D;1}^{n} |y_i - \\hat{y}_i|$。","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/tags/Machine-Learning/"}]},{"title":"ChatGPT是怎么炼成的","date":"2023-12-01T07:21:33.000Z","path":"2023/12/01/ChatGPT是怎么炼成的/","comments":true,"permalink":"http://noint.top/2023/12/01/ChatGPT%E6%98%AF%E6%80%8E%E4%B9%88%E7%82%BC%E6%88%90%E7%9A%84/","excerpt":"引言在人工智能领域，ChatGPT的出现标志着一个新时代的开始。作为一个基于大规模语言模型的聊天机器人，ChatGPT不仅改变了人们与技术的交互方式，还推动了AI技术的边界。本文旨在探讨ChatGPT的主要原理、发展历史，以及它可能对社会产生的影响和带来的新研究问题。 ChatGPT的主要原理ChatGPT的核心基于GPT（Generative Pre-trained Transformer）架构，这是一种革命性的自然语言处理技术。要理解ChatGPT的工作原理，我们需要从以下几个方面来深入探讨： Transformer架构Transformer是一种专为处理序列数据而设计的深度学习模型架构。它在2017年由Google的研究者提出，并迅速成为自然语言处理领域的标准。Transformer的核心特点是其使用了自注意力（Self-Attention）机制。这个机制使模型能够在处理一个单词时，同时考虑到句子中的其他单词，从而更好地理解上下文。 自注意力机制的数学原理 输入表示：Transformer接收一系列向量作为输入，这些向量通常是输入序列中每个元素（如单词）的嵌入表示。 查询、键和值：自注意力机制涉及三组权重矩阵——查询（Q）、键（K）和值（V）。这些矩阵是通过训练学习得到的。对于每个输入向量，模型使用这些权重矩阵分别计算查询、键和值。 注意力分数：模型计算查询和所有键之间的点积，以得出注意力分数。这个分数决定了在生成输出时应该给予每个值多少权重。 缩放点积注意力：为了避免在计算点积时数值过大，会将注意力分数除以键的维度的平方根，然后应用softmax函数来标准化分数。 输出计算：最后，这些分数与值相乘，然后相加，生成最终的输出向量。 层归一化和位置编码除了自注意力机制，Transformer还使用了层归一化（Layer Normalization）和位置编码（Positional Encoding）来进一步提升性能。 层归一化：这是一种标准化技术，用于稳定深度神经网络的训练过程。 位置编码：由于Transformer本身不处理序列的顺序信息，位置编码被加入到输入嵌入中，以提供序列中各元素的位置信息。 预训练和微调1. 预训练","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/tags/Machine-Learning/"}]},{"title":"Introduction to Machine Learning","date":"2023-11-28T09:37:19.000Z","path":"2023/11/28/Introduction-to-Machine-Learning/","comments":true,"permalink":"http://noint.top/2023/11/28/Introduction-to-Machine-Learning/","excerpt":"机器学习（Machine Learning, ML）是计算机科学的一个分支，它使计算机能够从数据中学习并做出决策或预测。它是人工智能（Artificial Intelligence, AI）的核心技术之一，涉及统计学、概率论、算法理论、数据挖掘等多个领域。 1. 机器学习的基础机器学习的基本概念可以从统计学中的回归分析理解起。假设有一个数据集${ (x_i, y_i); i &#x3D; 1, \\dots, n }$，其中$x_i$是特征，$y_i$是标签。机器学习的目标是找到一个函数$f$，使得$f(x_i)$尽可能接近$y_i$。这个过程通常涉及到最小化一个损失函数（loss function），例如平方误差损失： $$ L(f) &#x3D; \\frac{1}{n} \\sum_{i&#x3D;1}^n (f(x_i) - y_i)^2 $$ 2. 机器学习的类型机器学习主要分为三类：监督学习（Supervised Learning）、无监督学习（Unsupervised Learning）和强化学习（Reinforcement Learning）。 2.1 监督学习监督学习处理的是有标签的数据。常见的算法包括线性回归（Linear Regression）和逻辑回归（Logistic Regression）。在线性回归中，我们试图找到一组参数$\\theta$，使得预测值$\\hat{y} &#x3D; \\theta^T x$尽可能接近真实值$y$。损失函数通常是均方误差（MSE）： $$ J(\\theta) &#x3D; \\frac{1}{2n} \\sum_{i&#x3D;1}^n (\\theta^T x_i - y_i)^2 $$ 2.2 无监督学习","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/tags/Machine-Learning/"}]},{"title":"不同高级语言内存管理机制的汇编语言分析","date":"2023-11-11T01:43:47.000Z","path":"2023/11/11/内存管理机制的汇编语言分析/","comments":true,"permalink":"http://noint.top/2023/11/11/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%86%E6%9E%90/","excerpt":"一、背景说明在现代计算机编程中，内存管理是一个核心问题。不同的编程语言采用了不同的策略来处理内存分配和回收。本报告从汇编语言的角度，对比分析了Java的垃圾收集机制和C语言的手动内存管理方法。汇编语言作为一种低级语言，能够提供对程序运行时内存操作的直接视图，从而帮助理解这两种高级语言中的内存管理机制。 二、探索过程实验设置：使用Java和C语言编写了简单的程序来演示内存分配和释放。随后，通过编译器生成这些程序的汇编代码。 实验环境： 编译器：GCC用于C程序，Javac用于Java程序。 分析工具：GDB用于查看C程序的汇编代码，JITWatch用于分析Java程序的JIT编译和内存管理。 系统环境：Linux操作系统，以确保对汇编指令的兼容性和一致性。 编写测试程序： C程序：创建了一个程序，其中包含手动内存分配（使用malloc）和释放（使用free）的示例。 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct &#123; int id; char name[50];&#125; Person;int main() &#123; // 分配内存 Person *personPtr = (Person*) malloc(sizeof(Person)); if (personPtr == NULL) &#123; fprintf(stderr, &quot;内存分配失败\\n&quot;); return 1; &#125; // 使用分配的内存 personPtr-&gt;id = 1; strcpy(personPtr-&gt;name, &quot;YANG Dianchao&quot;); printf(&quot;ID: %d, Name: %s\\n&quot;, personPtr-&gt;id, personPtr-&gt;name); // 释放内存 free(personPtr); return 0;&#125; 这个程序定义了一个简单的Person结构体，并在堆上为其分配内存。 使用malloc函数进行内存分配，并检查分配是否成功。 对分配的内存进行读写操作，设置Person结构体的字段。 最后，使用free函数释放分配的内存。 使用GCC编译器来来生成汇编代码、编译此程序 123gcc -S memory_management_demo.cgcc -o memory_management_demo memory_management_demo.c Java程序：编写了一个创建对象并依赖垃圾收集器进行内存管理的程序。 123456789101112131415161718192021222324252627public class MemoryManagementDemo &#123; static class Person &#123; int id; String name; Person(int id, String name) &#123; this.id = id; this.name = name; &#125; void display() &#123; System.out.println(&quot;ID: &quot; + id + &quot;, Name: &quot; + name); &#125; &#125; public static void main(String[] args) &#123; // 创建Person对象 Person person = new Person(1, &quot;YANG Dianchao&quot;); // 使用对象 person.display(); // 退出main方法后，person对象变为垃圾收集的候选对象 &#125;&#125;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/categories/Computer-Science/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/tags/Computer-Science/"}]},{"title":"Hazards in Pipelined CPU","date":"2023-10-17T02:42:18.000Z","path":"2023/10/17/Hazards-in-Pipelined-CPU/","comments":true,"permalink":"http://noint.top/2023/10/17/Hazards-in-Pipelined-CPU/","excerpt":"在流水线CPU中，”hazards”（或称为冲突）是一种情况，它阻碍了流水线的连续和高效执行。这些冲突通常分为三类： 一、数据冲突（Data Hazards）数据冲突发生在一个指令需要使用上一个或几个指令尚未完成计算的数据结果。 Read After Write (RAW)：这是最常见的数据冲突类型。例如，第一条指令正在向寄存器R1写入数据，而第二条指令需要从R1读取数据。 解决方法：数据前推（Data Forwarding）或者暂停（Stalling）。 二、控制冲突（Control Hazards）","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/categories/Computer-Science/"},{"name":"Computer Organization and Design","slug":"Computer-Science/Computer-Organization-and-Design","permalink":"http://noint.top/categories/Computer-Science/Computer-Organization-and-Design/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/tags/Computer-Science/"}]},{"title":"Hello World","date":"2023-10-10T16:43:47.000Z","path":"2023/10/11/hello-world/","comments":true,"permalink":"http://noint.top/2023/10/11/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate","categories":[],"tags":[]}],"categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/categories/Computer-Science/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/categories/Machine-Learning/"},{"name":"Computer Organization and Design","slug":"Computer-Science/Computer-Organization-and-Design","permalink":"http://noint.top/categories/Computer-Science/Computer-Organization-and-Design/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/tags/Computer-Science/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/tags/Machine-Learning/"}]}