{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Noint","url":"http://noint.top","root":"/"},"posts":[{"title":"HTML基本知识","date":"2024-01-27T08:18:35.000Z","path":"2024/01/27/HTML基本知识/","comments":true,"permalink":"http://noint.top/2024/01/27/HTML%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/","excerpt":"前端开发简介前端开发主要关注于创建网页和应用程序的用户界面。它包括展示给用户的所有内容和元素，如文本、图像、滑块以及交互式元素。前端开发的核心技术包括HTML、CSS和JavaScript，它们共同作用于浏览器中，提供丰富的用户体验。 1.1 HTML基础HTML（超文本标记语言）是网页的骨架。它用于结构化信息，如定义段落、标题和链接。 示例代码： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;我的网页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;欢迎来到我的网站&lt;/h1&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;a href=&quot;https://www.zju.edu.cn&quot;&gt;访问浙江大学&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 这段代码展示了一个简单的HTML结构，包括头部（head）、标题（title）、正文（body）、标题标签（h1）、段落标签（p）和链接（a）。 1.2 CSS基础CSS（层叠样式表）用于设计和美化HTML元素。通过CSS，可以调整字体、颜色、间距和布局等。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/categories/Computer-Science/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/tags/Computer-Science/"}]},{"title":"Swift语言学习笔记","date":"2024-01-26T13:50:23.000Z","path":"2024/01/26/Swift语言学习笔记/","comments":true,"permalink":"http://noint.top/2024/01/26/Swift%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"关于 SwiftSwift 是一种非常好的编写软件的方式，无论是手机，台式机，服务器，还是其他运行代码的设备。它是一种安全，快速和互动的编程语言，将现代编程语言的精华和苹果工程师文化的智慧，以及来自开源社区的多样化贡献结合了起来。编译器对性能进行了优化，编程语言对开发进行了优化，两者互不干扰，鱼与熊掌兼得。 Swift 对于初学者来说也很友好。它是一门满足工业标准的编程语言，但又有着脚本语言般的表达力和可玩性。它支持代码预览（playgrounds），这个革命性的特性可以允许程序员在不编译和运行应用程序的前提下运行 Swift 代码并实时查看结果。 Swift 通过采用现代编程模式来避免大量常见编程错误： 变量始终在使用前初始化。 检查数组索引超出范围的错误。 检查整数是否溢出。 可选值确保明确处理 nil 值。 内存被自动管理。 错误处理允许从意外故障控制恢复。 Swift 代码被编译和优化，以充分利用现代硬件。语法和标准库是基于指导原则设计的，编写代码的明显方式也应该是最好的。安全性和速度的结合使得 Swift 成为从 “Hello，world！” 到整个操作系统的绝佳选择。 关于语法细节可参考：https://swift.bootcss.com/ 语法笔记2.1 说明Swift 包含了 C 和 Objective-C 上所有基础数据类型，Int 表示整型值； Double 和 Float 表示浮点型值； Bool 是布尔型值；String 是文本型数据。 Swift 还提供了三个基本的集合类型，Array、Set 和 Dictionary。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/categories/Computer-Science/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/tags/Computer-Science/"}]},{"title":"Introduction to Generative Learning","date":"2023-12-05T10:55:15.000Z","path":"2023/12/05/Introduction-to-Generative-Learning/","comments":true,"permalink":"http://noint.top/2023/12/05/Introduction-to-Generative-Learning/","excerpt":"生成学习的基本概念生成学习的核心思想是学习样本数据的概率分布。一旦学习到这种分布，就可以生成新的、与原始数据类似的样本。生成模型通常包括基于概率的模型，如高斯混合模型（Gaussian Mixture Model, GMM），和近年来流行的基于神经网络的模型，如生成对抗网络（Generative Adversarial Networks, GANs）和变分自编码器（Variational Autoencoders, VAEs）。 概率模型 生成学习的一个关键方面是使用概率模型来描述数据。例如，假设我们有一个数据集${x^{(1)}, x^{(2)}, …, x^{(m)}}$，我们希望学习这个数据集的概率分布$p(x)$。 对于简单的场景，可以考虑使用如高斯分布的参数化方法： $$ p(x; \\mu, \\sigma^2) &#x3D; \\frac{1}{\\sqrt{2\\pi\\sigma^2}} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}} $$ 其中，$\\mu$是均值，$\\sigma^2$是方差。 高斯混合模型（GMM） 高斯混合模型是一种常用的生成模型，它假设数据是由多个高斯分布混合而成的。其概率密度函数为： $$ p(x) &#x3D; \\sum_{k&#x3D;1}^K \\phi_k \\mathcal{N}(x; \\mu_k, \\Sigma_k) $$ 这里，$K$是混合成分的数量，$\\phi_k$是第$k$个成分的混合系数，$\\mathcal{N}(x; \\mu_k, \\Sigma_k)$是以$\\mu_k$为均值、$\\Sigma_k$为协方差矩阵的多变量高斯分布。 基于神经网络的生成模型生成对抗网络（GANs）生成对抗网络由两部分组成：生成器（Generator）和判别器（Discriminator）。生成器负责生成数据，而判别器负责判断数据是真实的还是由生成器生成的。GAN的训练过程可以看作是一个博弈过程，生成器试图生成越来越逼真的数据，而判别器试图越来越准确地区分真实数据和生成数据。 数学上，GAN的目标函数可以表示为： $$ \\min_G \\max_D V(D, G) &#x3D; \\mathbb{E}{x \\sim p{data}(x)}[\\log D(x)] + \\mathbb{E}_{z \\sim p_z(z)}[\\log(1 - D(G(z)))] $$ 其中，$G$是生成器，$D$是判别器，$z$是从某种概率分布$p_z(z)$（通常是高斯分布）中采样的噪声。","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/tags/Machine-Learning/"}]},{"title":"Introduction to Deep Learning","date":"2023-12-05T09:48:02.000Z","path":"2023/12/05/Introduction-to-Deep-Learning/","comments":true,"permalink":"http://noint.top/2023/12/05/Introduction-to-Deep-Learning/","excerpt":"基本概念深度学习的核心是深度神经网络（DNNs），它们是由多层神经元组成的网络结构。每一层由多个神经元组成，这些神经元接收来自前一层的输入，并产生输出到下一层。最简单的神经网络是感知器（Perceptron），它是一个单层的网络结构。 神经元（Neuron） 神经元是构成神经网络的基本单元。每个神经元接收来自其他神经元的输入信号，然后处理这些信号，并产生输出。数学上，一个神经元的操作可以表示为： $$ f(x) &#x3D; \\phi\\left(\\sum_{i&#x3D;1}^n w_i x_i + b\\right) $$ 其中，$x_1, x_2, …, x_n$ 是输入，$w_1, w_2, …, w_n$ 是权重，$b$ 是偏置项，$\\phi$ 是激活函数。 激活函数（Activation Function） 激活函数是用来加入非线性因素的函数，使得神经网络可以学习更复杂的模式。常见的激活函数有Sigmoid函数、ReLU函数等。 Sigmoid函数：$\\sigma(x) &#x3D; \\frac{1}{1 + e^{-x}}$ ReLU函数：$ReLU(x) &#x3D; max(0, x)$ 损失函数（Loss Function） 损失函数用于评估神经网络的性能。它计算了神经网络的预测值和实际值之间的差异。常见的损失函数包括均方误差（MSE）和交叉熵损失（Cross-Entropy Loss）。 均方误差：$MSE &#x3D; \\frac{1}{n}\\sum_{i&#x3D;1}^n(y_i - \\hat{y}_i)^2$ 交叉熵损失：$CE &#x3D; -\\sum_{i&#x3D;1}^n y_i \\log(\\hat{y}_i)$ 数学原理反向传播（Backpropagation）","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/tags/Machine-Learning/"}]},{"title":"Classification","date":"2023-12-03T14:38:32.000Z","path":"2023/12/03/Classification/","comments":true,"permalink":"http://noint.top/2023/12/03/Classification/","excerpt":"引言在人工智能和统计学领域，分类分析是一种关键技术，用于识别和预测数据所属的类别。与回归分析主要处理连续变量不同，分类处理的是离散的输出标签。本文旨在探讨分类的基本概念、算法以及在现实世界的应用。 一. 分类分析简介分类分析是一种监督学习方法，旨在基于一组输入变量预测离散的输出变量（类别标签）。其目标是从数据中学习一个模型，能够准确地将新数据点分类到特定的类别中。 二. 常见分类算法1. 决策树决策树是一种简单直观的分类方法，通过一系列规则将数据分割成不同的类别。每个决策节点代表对某个属性的测试，而每个叶节点代表一个类别。 决策树的构建过程 选择最优特征：首先选择一个最优的特征作为根节点。”最优”通常是通过信息增益（在ID3算法中使用）或基尼不纯度（在CART算法中使用）来决定的。 分裂节点：基于这个特征的不同值，数据集被分裂成几个子集。每个子集接着创建一个新的节点。 递归构建：对每个子集重复以上步骤，直到所有的特征都被使用，或者每个子集都不能进一步分裂（所有的元素都属于同一个类别，或达到预设的停止条件）。 剪枝处理：为了避免过拟合，可能需要对树进行剪枝。剪枝涉及删除部分子树或节点，以简化模型。 决策树的数学原理1. 信息增益（Information Gain）信息增益是用来决定决策树中节点分裂的关键标准之一。它基于信息熵的概念。信息熵是度量样本集合纯度最常用的方法，定义如下： $$ \\text{Entropy}(S) &#x3D; -\\sum_{i&#x3D;1}^{n} p_i \\log_2 p_i $$ 其中，$S$是当前数据集，$n$是不同类别的数量，$p_i$是选择该类别的概率。熵越大，数据的不确定性越高。 信息增益计算公式如下： $$ \\text{Information Gain}(S, A) &#x3D; \\text{Entropy}(S) - \\sum_{v \\in \\text{Values}(A)} \\frac{|S_v|}{|S|} \\text{Entropy}(S_v) $$ 这里，$A$是决定进行分裂的特征，$\\text{Values}(A)$是这个特征所有可能的值，$S_v$是特征$A$上值为$v$的子集，$|S_v|$和$|S|$分别是子集和原始集合的大小。 2. 基尼不纯度（Gini Impurity）基尼不纯度是CART（分类和回归树）算法中用于决策树构建的标准。它的计算公式是： $$ \\text{Gini}(S) &#x3D; 1 - \\sum_{i&#x3D;1}^{n} p_i^2 $$ 这里，$S$代表数据集，$n$是类别的数量，$p_i$是类别$i$在数据集$S$中的相对频率。基尼不纯度反映了从集合中随机选取两个元素，它们属于不同类别的概率。 3. 决策树的分裂在每个节点，算法将选择信息增益最高（或基尼不纯度最低）的特征进行分裂。这个过程会递归地继续，直到达到停止的条件，比如树达到了最大深度，或者节点中的样本数小于预定阈值。 4. 剪枝（Pruning）为了避免过拟合，决策树可能需要剪枝。一种常见的剪枝方法是代价复杂度剪枝（Cost Complexity Pruning），其基本思想是通过一个参数$\\alpha$（复杂度参数）来平衡树的深度和训练数据上的表现。 5. 决策树的决策过程当构建好一个决策树后，对于一个新的样本，我们从根节点开始，根据其特征值走向对应的分支，直到达到叶节点。叶节点的值即为模型对该样本的预测结果。 2. 支持向量机 (SVM)支持向量机是一种强大的分类器，它通过找到一个最优的超平面来区分不同类别的数据。SVM在处理高维数据和非线性问题方面表现出色。","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/tags/Machine-Learning/"}]},{"title":"Gradient Descent","date":"2023-12-02T05:23:41.000Z","path":"2023/12/02/Gradient-Descent/","comments":true,"permalink":"http://noint.top/2023/12/02/Gradient-Descent/","excerpt":"梯度下降（Gradient Descent）是一种常用于机器学习和深度学习中的优化算法，用于最小化一个函数。这个函数通常被称为“代价函数”或“损失函数”，它衡量了模型预测值与实际值之间的差距。梯度下降的核心思想是，通过迭代的方式逐步调整参数以找到使代价函数最小化的参数值。 数学推理为了理解梯度下降，我们首先需要理解“梯度”的概念。在多变量微积分中，一个函数在某一点的梯度由该点处的偏导数构成，它指向该函数增长最快的方向。因此，梯度的反方向就是函数下降最快的方向。 假设我们有一个代价函数 $ J(\\theta) $，其中 $\\theta $是模型的参数。我们的目标是找到使 $ J(\\theta) $最小的$\\theta $值。梯度下降算法会执行以下步骤： 随机初始化参数 $\\theta $。 计算代价函数 $ J(\\theta) $ 在当前 $\\theta $ 下的梯度 $ \\nabla J(\\theta) $。 更新 $\\theta $，使其沿着梯度的反方向移动：$ \\theta :&#x3D; \\theta - \\alpha \\nabla J(\\theta) $，其中 $\\alpha $ 是学习率，控制步长大小。 重复步骤2和3，直到达到收敛条件（例如，梯度的大小足够小或迭代次数达到某个阈值）。 推理过程 以一个简单的线性回归模型为例，假设我们有一个代价函数 $J(\\theta) &#x3D; \\frac{1}{2m} \\sum_{i&#x3D;1}^{m} (h_\\theta(x^{(i)}) - y^{(i)})^2 $，其中 $h_\\theta(x) &#x3D; \\theta^T x $是我们的假设函数，$ m $ 是样本数量。 我们需要计算 $J(\\theta) $ 对 $\\theta$ 的偏导数，即梯度： $$ \\nabla J(\\theta) &#x3D; \\frac{\\partial}{\\partial \\theta} J(\\theta) &#x3D; \\frac{1}{m} \\sum_{i&#x3D;1}^{m} (h_\\theta(x^{(i)}) - y^{(i)}) x^{(i)} $$ 然后，我们使用梯度下降规则更新 $\\theta$： $$\\theta :&#x3D; \\theta - \\alpha \\nabla J(\\theta) $$ 这意味着我们减去了梯度与学习率 $\\alpha$的乘积，以使 $J(\\theta)$最小化。 举例 假设我们的数据集包含以下点：((1, 1), (2, 2), (3, 3))，我们想要找到一条直线 $ y &#x3D; \\theta x $来拟合这些点。 随机初始化 $\\theta$，比如 $\\theta &#x3D; 0$。 计算 $J(\\theta)$ 的梯度：在 $\\theta &#x3D; 0 $ 时，$\\nabla J(\\theta) &#x3D; \\frac{1}{3} \\sum_{i&#x3D;1}^{3} (-i) \\cdot i &#x3D; -\\frac{14}{3}$。 选择一个学习率，比如 $ \\alpha &#x3D; 0.01$，并更新 $\\theta$：$ \\theta :&#x3D; 0 - 0.01 \\cdot (-\\frac{14}{3}) &#x3D; \\frac{14}{300}$。 重复步骤2和3，直到 $ \\theta $ 收敛到最优解。 通过这个过程，梯度下降算法能够逐渐找到最佳的 $\\theta$ 值来最小化代价函数 $J(\\theta)$，从而找到最佳的模型参数。","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/tags/Machine-Learning/"}]},{"title":"Regression Analysis","date":"2023-12-01T14:39:54.000Z","path":"2023/12/01/Regression-Analysis/","comments":true,"permalink":"http://noint.top/2023/12/01/Regression-Analysis/","excerpt":"引言在人工智能和统计学领域，回归分析是一种核心技术，它用于揭示变量之间的关系、预测未来数据点，以及在实际应用中的数据驱动决策。本文将深入探讨回归分析的基本原理、数学基础以及其在现实世界的应用。 一. 回归分析简介回归分析是一种统计方法，用于研究一个或多个自变量（解释变量）与因变量（响应变量）之间的关系。它的目标是找到一个数学模型，能够最佳地描述这种依赖关系。 二. 常见回归类型1. 线性回归线性回归是最基本的回归形式，其模型假设因变量 y 和自变量 x 之间存在线性关系，可以表示为： $$y &#x3D; \\beta_0 + \\beta_1x + \\epsilon$$ 其中，$\\beta_0$ 是截距，$\\beta_1$ 是斜率，而 $\\epsilon$ 是误差项。线性回归的核心在于找出这些系数的最佳估计，通常通过最小化残差平方和（RSS）来实现。 均方误差 (MSE): 这是线性回归中最常用的损失函数。它计算了预测值与实际值之间差的平方的平均值。公式为：$MSE &#x3D; \\frac{1}{n} \\sum_{i&#x3D;1}^{n}(y_i - \\hat{y}_i)^2$，其中 $y_i$ 是实际值，$\\hat{y}_i$ 是预测值。 绝对误差 (MAE): MAE 是另一种常见的损失函数，它计算预测值与实际值之间差的绝对值的平均。公式为：$MAE &#x3D; \\frac{1}{n} \\sum_{i&#x3D;1}^{n} |y_i - \\hat{y}_i|$。","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/tags/Machine-Learning/"}]},{"title":"ChatGPT是怎么炼成的","date":"2023-12-01T07:21:33.000Z","path":"2023/12/01/ChatGPT是怎么炼成的/","comments":true,"permalink":"http://noint.top/2023/12/01/ChatGPT%E6%98%AF%E6%80%8E%E4%B9%88%E7%82%BC%E6%88%90%E7%9A%84/","excerpt":"引言在人工智能领域，ChatGPT的出现标志着一个新时代的开始。作为一个基于大规模语言模型的聊天机器人，ChatGPT不仅改变了人们与技术的交互方式，还推动了AI技术的边界。本文旨在探讨ChatGPT的主要原理、发展历史，以及它可能对社会产生的影响和带来的新研究问题。 ChatGPT的主要原理ChatGPT的核心基于GPT（Generative Pre-trained Transformer）架构，这是一种革命性的自然语言处理技术。要理解ChatGPT的工作原理，我们需要从以下几个方面来深入探讨： Transformer架构Transformer是一种专为处理序列数据而设计的深度学习模型架构。它在2017年由Google的研究者提出，并迅速成为自然语言处理领域的标准。Transformer的核心特点是其使用了自注意力（Self-Attention）机制。这个机制使模型能够在处理一个单词时，同时考虑到句子中的其他单词，从而更好地理解上下文。 自注意力机制的数学原理 输入表示：Transformer接收一系列向量作为输入，这些向量通常是输入序列中每个元素（如单词）的嵌入表示。 查询、键和值：自注意力机制涉及三组权重矩阵——查询（Q）、键（K）和值（V）。这些矩阵是通过训练学习得到的。对于每个输入向量，模型使用这些权重矩阵分别计算查询、键和值。 注意力分数：模型计算查询和所有键之间的点积，以得出注意力分数。这个分数决定了在生成输出时应该给予每个值多少权重。 缩放点积注意力：为了避免在计算点积时数值过大，会将注意力分数除以键的维度的平方根，然后应用softmax函数来标准化分数。 输出计算：最后，这些分数与值相乘，然后相加，生成最终的输出向量。 层归一化和位置编码除了自注意力机制，Transformer还使用了层归一化（Layer Normalization）和位置编码（Positional Encoding）来进一步提升性能。 层归一化：这是一种标准化技术，用于稳定深度神经网络的训练过程。 位置编码：由于Transformer本身不处理序列的顺序信息，位置编码被加入到输入嵌入中，以提供序列中各元素的位置信息。 预训练和微调1. 预训练","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/tags/Machine-Learning/"}]},{"title":"Introduction to Machine Learning","date":"2023-11-28T09:37:19.000Z","path":"2023/11/28/Introduction-to-Machine-Learning/","comments":true,"permalink":"http://noint.top/2023/11/28/Introduction-to-Machine-Learning/","excerpt":"机器学习（Machine Learning, ML）是计算机科学的一个分支，它使计算机能够从数据中学习并做出决策或预测。它是人工智能（Artificial Intelligence, AI）的核心技术之一，涉及统计学、概率论、算法理论、数据挖掘等多个领域。 1. 机器学习的基础机器学习的基本概念可以从统计学中的回归分析理解起。假设有一个数据集${ (x_i, y_i); i &#x3D; 1, \\dots, n }$，其中$x_i$是特征，$y_i$是标签。机器学习的目标是找到一个函数$f$，使得$f(x_i)$尽可能接近$y_i$。这个过程通常涉及到最小化一个损失函数（loss function），例如平方误差损失： $$ L(f) &#x3D; \\frac{1}{n} \\sum_{i&#x3D;1}^n (f(x_i) - y_i)^2 $$ 2. 机器学习的类型机器学习主要分为三类：监督学习（Supervised Learning）、无监督学习（Unsupervised Learning）和强化学习（Reinforcement Learning）。 2.1 监督学习监督学习处理的是有标签的数据。常见的算法包括线性回归（Linear Regression）和逻辑回归（Logistic Regression）。在线性回归中，我们试图找到一组参数$\\theta$，使得预测值$\\hat{y} &#x3D; \\theta^T x$尽可能接近真实值$y$。损失函数通常是均方误差（MSE）： $$ J(\\theta) &#x3D; \\frac{1}{2n} \\sum_{i&#x3D;1}^n (\\theta^T x_i - y_i)^2 $$ 2.2 无监督学习无监督学习处理没有标签的数据，目的是发现数据的内在结构。聚类（Clustering）和主成分分析（PCA）是常用的无监督学习方法。例如，在PCA中，目标是找到一个投影方向，使得数据在这个方向上的方差最大。数学上，这可以通过求解一个特征值问题来实现： $$ X^T X v &#x3D; \\lambda v $$ 其中，$X$是去中心化后的数据矩阵。 2.3 强化学习强化学习是一种学习策略来实现目标。它通过试错（trial and error）来学习最佳策略。在强化学习中，智能体（agent）在环境中采取行动，并根据环境的反馈来调整其策略。马尔可夫决策过程（Markov Decision Process, MDP）是强化学习的数学模型，其核心是一个四元组$(S, A, P, R)$，分别表示状态、动作、状态转移概率和回报函数。 3. 机器学习的算法机器学习算法众多，每种算法都有其特点和适用场景。 3.1 决策树","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/tags/Machine-Learning/"}]},{"title":"不同高级语言内存管理机制的汇编语言分析","date":"2023-11-11T01:43:47.000Z","path":"2023/11/11/内存管理机制的汇编语言分析/","comments":true,"permalink":"http://noint.top/2023/11/11/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%86%E6%9E%90/","excerpt":"一、背景说明在现代计算机编程中，内存管理是一个核心问题。不同的编程语言采用了不同的策略来处理内存分配和回收。本报告从汇编语言的角度，对比分析了Java的垃圾收集机制和C语言的手动内存管理方法。汇编语言作为一种低级语言，能够提供对程序运行时内存操作的直接视图，从而帮助理解这两种高级语言中的内存管理机制。 二、探索过程实验设置：使用Java和C语言编写了简单的程序来演示内存分配和释放。随后，通过编译器生成这些程序的汇编代码。 实验环境： 编译器：GCC用于C程序，Javac用于Java程序。 分析工具：GDB用于查看C程序的汇编代码，JITWatch用于分析Java程序的JIT编译和内存管理。 系统环境：Linux操作系统，以确保对汇编指令的兼容性和一致性。 编写测试程序： C程序：创建了一个程序，其中包含手动内存分配（使用malloc）和释放（使用free）的示例。 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct &#123; int id; char name[50];&#125; Person;int main() &#123; // 分配内存 Person *personPtr = (Person*) malloc(sizeof(Person)); if (personPtr == NULL) &#123; fprintf(stderr, &quot;内存分配失败\\n&quot;); return 1; &#125; // 使用分配的内存 personPtr-&gt;id = 1; strcpy(personPtr-&gt;name, &quot;YANG Dianchao&quot;); printf(&quot;ID: %d, Name: %s\\n&quot;, personPtr-&gt;id, personPtr-&gt;name); // 释放内存 free(personPtr); return 0;&#125; 这个程序定义了一个简单的Person结构体，并在堆上为其分配内存。 使用malloc函数进行内存分配，并检查分配是否成功。 对分配的内存进行读写操作，设置Person结构体的字段。 最后，使用free函数释放分配的内存。 使用GCC编译器来来生成汇编代码、编译此程序 123gcc -S memory_management_demo.cgcc -o memory_management_demo memory_management_demo.c Java程序：编写了一个创建对象并依赖垃圾收集器进行内存管理的程序。 123456789101112131415161718192021222324252627public class MemoryManagementDemo &#123; static class Person &#123; int id; String name; Person(int id, String name) &#123; this.id = id; this.name = name; &#125; void display() &#123; System.out.println(&quot;ID: &quot; + id + &quot;, Name: &quot; + name); &#125; &#125; public static void main(String[] args) &#123; // 创建Person对象 Person person = new Person(1, &quot;YANG Dianchao&quot;); // 使用对象 person.display(); // 退出main方法后，person对象变为垃圾收集的候选对象 &#125;&#125;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/categories/Computer-Science/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/tags/Computer-Science/"}]},{"title":"Hazards in Pipelined CPU","date":"2023-10-17T02:42:18.000Z","path":"2023/10/17/Hazards-in-Pipelined-CPU/","comments":true,"permalink":"http://noint.top/2023/10/17/Hazards-in-Pipelined-CPU/","excerpt":"在流水线CPU中，”hazards”（或称为冲突）是一种情况，它阻碍了流水线的连续和高效执行。这些冲突通常分为三类： 一、数据冲突（Data Hazards）数据冲突发生在一个指令需要使用上一个或几个指令尚未完成计算的数据结果。 Read After Write (RAW)：这是最常见的数据冲突类型。例如，第一条指令正在向寄存器R1写入数据，而第二条指令需要从R1读取数据。 解决方法：数据前推（Data Forwarding）或者暂停（Stalling）。 二、控制冲突（Control Hazards）","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/categories/Computer-Science/"},{"name":"Computer Organization and Design","slug":"Computer-Science/Computer-Organization-and-Design","permalink":"http://noint.top/categories/Computer-Science/Computer-Organization-and-Design/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/tags/Computer-Science/"}]},{"title":"Hello World","date":"2023-10-10T16:43:47.000Z","path":"2023/10/11/hello-world/","comments":true,"permalink":"http://noint.top/2023/10/11/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate","categories":[],"tags":[]},{"title":"Computer composition_Vivado","date":"2023-06-07T06:58:43.000Z","path":"2023/06/07/Computer-composition-Vivado/","comments":true,"permalink":"http://noint.top/2023/06/07/Computer-composition-Vivado/","excerpt":"《计算机组成与设计》实验报告 姓名：杨殿超 学院：计算机科学与技术学院 专业：计算机科学与技术 邮箱：nointiiii@gmail.com 报告日期: 4月5日 Lab0 &lt;Vivado 介绍和模块封装&gt; &lt;3200102318&gt; &lt;杨殿超&gt; &#x6e;&#111;&#105;&#110;&#x74;&#x69;&#x69;&#x69;&#105;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d; 操作方法与实验步骤一：VIVADO 工具学习任务：利用 VIVADO 完成 water_LED 的全流程设计新建工程 Water_LED，选 择 芯 片 为 xc7k160tffg676-2L 。 添加源文件 Water_LED.v. 通过一个计数器 (C0) 控制 LED 灯的移位速度，当计数器到达预设值时，将 LED 灯循环左移。设计方案如下： 使用 4 位寄存器 LED_o 表示 4 个 LED 灯的状态。 使用 32 位寄存器 C0 作为计数器。 时钟上升沿触发计数和 LED 灯的状态更新。 当复位信号 RSTn_i 为低电平时，将 LED_o 初始化为 ‘4b1’，将计数器 C0 清零。 在正常工作状态下，计数器 C0 每个时钟周期加 1。 当计数器 C0 达到预设值 100,000,000 时，将 LED_o 左移一位。如果 LED_o 达到 ‘4b1000’，则重新设置为 ‘4b1’。并将计数器 C0 清零。 如果计数器 C0 未达到预设值，LED_o 保持不变。 预计结果是，LED 灯会以预设的速度循环左移，呈现出水灯效果。 代码如下 1234567891011121314151617181920212223242526272829303132module Water_LED( input CLK_i, // 输入时钟信号 input RSTn_i, // 低有效复位信号 output reg [3:0]LED_o // 输出，表示四个LED灯的状态);reg [31:0]C0; // 32位计数器// 时钟上升沿触发的过程always @(posedge CLK_i) if(!RSTn_i) begin // 当复位信号为低时，初始化LED灯状态和计数器值 LED_o &lt;= 4&#x27;b1; C0 &lt;= 32&#x27;h0; end else begin if(C0 == 32&#x27;d100_000_000) begin // 当计数器值达到预设值时，LED灯左移，并清零计数器 C0 &lt;= 32&#x27;h0; if(LED_o == 4&#x27;b1000) LED_o &lt;= 4&#x27;b1; else LED_o &lt;= LED_o &lt;&lt; 1; end else begin // 计数器递增 C0 &lt;= C0 + 1&#x27;b1; // 保持LED灯状态不变 LED_o &lt;= LED_o; end endendmodule 编写仿真代码： 提供时钟信号和复位信号，并观察输出 LED 灯状态的变化。设计方案如下： 创建测试模块 Water_LED_tb。 定义输入信号 CLK_i 和 RSTn_i，以及输出信号 LED_o。 实例化 Water_LED 模块，并将输入输出信号连接到实例。 生成一个周期为 10 时间单位的时钟信号。 在仿真开始时，将 CLK_i 设置为 0，RSTn_i 设置为 0。 100 时间单位后，将 RSTn_i 设置为 1，模块开始正常工作。 预计结果是，观察到 Water_LED 模块中的 LED 灯在 RSTn_i 变为高电平后，开始呈现水灯效果。 12345678910111213141516171819202122module Water_LED_tb; reg CLK_i; // 输入时钟信号 reg RSTn_i; // 低有效复位信号 wire [3:0]LED_o; // 输出，表示四个LED灯的状态 // 实例化 Water_LED 模块并连接信号 Water_LED Water_LED_U( .CLK_i(CLK_i), .RSTn_i(RSTn_i), .LED_o(LED_o) ); // 生成周期为10时间单位的时钟信号 always #5 CLK_i = ~CLK_i; initial begin // 初始化时钟和复位信号 CLK_i = 0; RSTn_i = 0; #100 RSTn_i = 1; // 100时间单位后，将复位信号设为高，模块开始正常工作 endendmodule 模拟波形如下： 新建引脚约束文件 Water_LED.xdc，代码如下： 1234567891011121314151617181920212223#系统时钟set_property IOSTANDARD LVCMOS18 [get_ports CLK_i]set_property PACKAGE_PIN AC18 [get_ports CLK_i]#系统复位set_property IOSTANDARD LVCMOS18 [get_ports RSTn_i]set_property PACKAGE_PIN W13 [get_ports RSTn_i]#LED并行接口set_property IOSTANDARD LVCMOS33 [get_ports &#123;LED_o[0]&#125;]set_property PACKAGE_PIN W23 [get_ports &#123;LED_o[0]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;LED_o[1]&#125;]set_property PACKAGE_PIN AB26 [get_ports &#123;LED_o[1]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;LED_o[2]&#125;]set_property PACKAGE_PIN Y25 [get_ports &#123;LED_o[2]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;LED_o[3]&#125;]set_property PACKAGE_PIN AA23 [get_ports &#123;LED_o[3]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;LED_o[4]&#125;] set_property PACKAGE_PIN Y23 [get_ports &#123;LED_o[4]&#125;] set_property IOSTANDARD LVCMOS33 [get_ports &#123;LED_o[5]&#125;] set_property PACKAGE_PIN Y22 [get_ports &#123;LED_o[5]&#125;] set_property IOSTANDARD LVCMOS33 [get_ports &#123;LED_o[6]&#125;] set_property PACKAGE_PIN AE21 [get_ports &#123;LED_o[6]&#125;] set_property IOSTANDARD LVCMOS33 [get_ports &#123;LED_o[7]&#125;] set_property PACKAGE_PIN AF24 [get_ports &#123;LED_o[7]&#125;] 导入后文件结构如图 、 二：自定义模块设计学习任务：利用 VIVADO 完成多选器（MUX） 和逻辑部件（LOGIC）的设计和封装,以 MUX2T1_5 为例 这是一个简单的2输入1输出5位宽度的多路复用器（MUX）模块。其设计思路是根据选择信号s的值来选择两个输入信号I0和I1中的一个作为输出信号o。 设计方案： 输入信号：I0和I1，宽度为5位（[4:0]）； 选择信号：s，宽度为1位； 输出信号：o，宽度为5位（[4:0]）。 预计结果： 根据选择信号s的值，多路复用器模块将从输入信号I0和I1中选择一个作为输出信号o： 当s为0时，输出信号o将等于输入信号I0； 当s为1时，输出信号o将等于输入信号I1。 12345678910111213module MUX2T1_5( input [4:0] I0, // 5位输入信号I0 input [4:0] I1, // 5位输入信号I1 input s, // 选择信号s output [4:0] o // 5位输出信号o ); // 根据选择信号s的值，将I1或I0分配给输出信号o // 当s为0时，o = I0 // 当s为1时，o = I1 assign o = s ? I1 : I0;endmodule 编写仿真代码： 设计方案： 实例化MUX2T1_5模块； 在initial语句块中，改变输入信号I0、I1和选择信号s的值。 预计结果： 当选择信号s为0时，输出信号o应等于输入信号I0； 当选择信号s为1时，输出信号o应等于输入信号I1。 123456789101112131415161718192021module MUX2T1_5_TB; reg [4:0] I0; // 5位输入信号I0 reg [4:0] I1; // 5位输入信号I1 reg s; // 选择信号s wire [4:0] o; // 5位输出信号o // 实例化MUX2T1_5模块 MUX2T1_5 MUX2T1_5_U( .I0(I0), .I1(I1), .s(s), .o(o) ); initial begin s = 0; // 设置选择信号s为0 I0 = 0; // 设置输入信号I0的值 I1 = 1; // 设置输入信号I1的值 #50 s = 1; // 50时间单位后，设置选择信号s为1 endendmodule 之后进行封装。点击任务栏 Tools-&gt;Create and package new IP，之后一直选择Next，直到跳出 Package IP 界面，选择 Review and Package-&gt;Package IP，封装成功。 有源文件封装： 无源文件封装： 三：基本逻辑模块的原理学习、Xilinx IP 生成我们这里对一个算数逻辑单元进行仿真验证，提供使用的仿真代码与波形 我们这里使用add_32来验证： 123456789module add_32( input [31:0] A, input [31:0] B, output [31:0] result);assign result = A + B;endmodule 仿真代码如下： 12345678910111213141516171819202122232425262728module add_32_tb; reg [31:0] A; reg [31:0] B; wire [31:0] result; // 实例化add_32模块 add_32 add_32_( .A(A), .B(B), .result(result) ); initial begin A = 32&#x27;d123; B = 32&#x27;d321; #10; A = 32&#x27;hFFFFFFFF; B = 32&#x27;h00000001; #10; A = 32&#x27;hFFFFFFFF; B = 32&#x27;d9; #10; $finish; endendmodule 波形如图： 在 VIVADO 环境中建立 OExp01-Element 工程并完成基本模块调用。 新建工程 0Exp00-Element，选择芯片。添加 IP，选择 Settings-&gt;IP-&gt;Repository，按路径添加之前写的 mux 和 logic模块。点击 IP INTEGRATER-&gt;Create Block Design，创建 0Exp00_Element.bd，通过点击“+”添加之前封装的 IP，结果如下： 四：学习利用 VIVADO 生成 Xilinx 库中的 IP了解实验板的资源情况，熟悉Block Design的设计流程，完成实验平台muxctrl的构建 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697module OExp01_muxctrl (I0, I1, o_0, s, s1, s2); input [4:0]I0; input [4:0]I1; output [4:0]o_0; input [1:0]s; input s1; input [2:0]s2; wire [4:0]I0_0_1; wire [4:0]I1_0_1; wire [4:0]MUX2T1_5_0_o; wire [4:0]MUX2T1_5_1_o; wire [4:0]MUX4T1_5_0_o; wire [7:0]MUX8T1_8_0_o; wire s_0_1; wire [2:0]s_0_2; wire [1:0]s_0_3; wire [7:0]xlconcat_0_dout; wire [7:0]xlconcat_1_dout; wire [4:0]xlconstant_0_dout; wire [4:0]xlconstant_1_dout; wire [7:0]xlconstant_2_dout; wire [0:0]xlconstant_3_dout; wire [3:0]xlslice_0_Dout; wire [3:0]xlslice_1_Dout; wire [4:0]xlslice_2_Dout; wire [4:0]xlslice_3_Dout; assign I0_0_1 = I0[4:0]; assign I1_0_1 = I1[4:0]; assign o_0[4:0] = MUX4T1_5_0_o; assign s_0_1 = s1; assign s_0_2 = s2[2:0]; assign s_0_3 = s[1:0]; OExp01_muxctrl_MUX2T1_5_0_0 MUX2T1_5_0 (.I0(I0_0_1), .I1(I1_0_1), .o(MUX2T1_5_0_o), .s(s_0_1)); OExp01_muxctrl_MUX2T1_5_1_1 MUX2T1_5_1 (.I0(I0_0_1), .I1(I1_0_1), .o(MUX2T1_5_1_o), .s(xlconstant_3_dout)); OExp01_muxctrl_MUX4T1_5_0_0 MUX4T1_5_0 (.I0(xlslice_2_Dout), .I1(xlslice_3_Dout), .I2(xlconstant_1_dout), .I3(xlconstant_0_dout), .o(MUX4T1_5_0_o), .s(s_0_3)); OExp01_muxctrl_MUX8T1_8_0_0 MUX8T1_8_0 (.I0(xlconcat_0_dout), .I1(xlconcat_1_dout), .I2(xlconstant_2_dout), .I3(xlconstant_2_dout), .I4(xlconstant_2_dout), .I5(xlconstant_2_dout), .I6(xlconstant_2_dout), .I7(xlconstant_2_dout), .o(MUX8T1_8_0_o), .s(s_0_2)); OExp01_muxctrl_xlconcat_0_0 xlconcat_0 (.In0(xlslice_0_Dout), .In1(xlslice_1_Dout), .dout(xlconcat_0_dout)); OExp01_muxctrl_xlconcat_1_0 xlconcat_1 (.In0(xlslice_1_Dout), .In1(xlslice_0_Dout), .dout(xlconcat_1_dout)); OExp01_muxctrl_xlconstant_0_1 xlconstant_0 (.dout(xlconstant_0_dout)); OExp01_muxctrl_xlconstant_1_0 xlconstant_1 (.dout(xlconstant_1_dout)); OExp01_muxctrl_xlconstant_2_0 xlconstant_2 (.dout(xlconstant_2_dout)); OExp01_muxctrl_xlconstant_0_0 xlconstant_3 (.dout(xlconstant_3_dout)); OExp01_muxctrl_xlslice_0_0 xlslice_0 (.Din(MUX2T1_5_1_o), .Dout(xlslice_0_Dout)); OExp01_muxctrl_xlslice_1_0 xlslice_1 (.Din(MUX2T1_5_0_o), .Dout(xlslice_1_Dout)); OExp01_muxctrl_xlslice_2_0 xlslice_2 (.Din(MUX8T1_8_0_o), .Dout(xlslice_2_Dout)); OExp01_muxctrl_xlslice_3_0 xlslice_3 (.Din(xlconcat_1_dout), .Dout(xlslice_3_Dout));endmodule 实验结果与分析一：VIVADO 工具学习LED 灯以预设的速度循环移动，呈现出水灯效果，reset正常工作，符合要求。 二：自定义模块设计学习MUX2T1_5仿真波形如下： 当选择信号s为0时，输出信号o应等于输入信号I0； 当选择信号s为1时，输出信号o应等于输入信号I1。 符合预期，两种封装方式也符合预期，在过程中可以看到截图。 三：基本逻辑模块的原理学习、Xilinx IP 生成算数单元验证add_32 $$123+321&#x3D;444\\-1+1&#x3D;1\\-1+9&#x3D;8$$符合预期。同时OExp01-Element 工程完成基本模块调用 四：学习利用 VIVADO 生成 Xilinx 库中的 IPmuxctrl 上板: s&#x3D;2’b00,s1&#x3D;1’b0,s2&#x3D;3’b000,I1[0]&#x3D;1’b1, I0[3:0]&#x3D;4’b1111，灯全亮 s&#x3D;2’b00,s1&#x3D;1’b0,s2&#x3D;3’b001，I0[0]&#x3D;1’b1,I1[3:0]&#x3D;4’b1111时，仅o_0[0],o_0[4]亮 s&#x3D;2’b00,s1&#x3D;1’b0,s2&#x3D;3’b010，I0[0]&#x3D;1’b1,I1[3:0]&#x3D;4’b1111时，仅o_0[0]亮 s1&#x3D;1’b1，无论s2&#x3D;3’b000或3’b001，只要I1[3:0]&#x3D;4’b1111，灯都全亮 s&#x3D;2’b11时，所有灯都暗 符合预期 讨论、心得本次实验我学习设计流水灯，封装并尝试调用逻辑模块和选择器模块，设计 muxctrl，熟悉了 vivado 的一 些基本操作，封装的逻辑模块和选择器模块也会在之后的实验中派上用处。 思考题助教在做《计算机体系结构》实验时，在 Message Window 中看到了下列错误提示： [Drc 23-20] Rule violation (NSTD-1) Unspecified I&#x2F;O Standard: 41 out of 41 logical ports use I&#x2F;O standard (IOSTANDARD) value ‘DEFAULT’, instead of a user assigned specific value. This may cause I&#x2F;O contention or incompatibility with the board power or connectivity affecting performance, signal integrity or in extreme cases cause damage to the device or the components to which it is connected. To correct this violation, specify all I&#x2F;O standards. This design will fail to generate a bitstream unless all logical ports have a user specified I&#x2F;O standard value defined. To allow bitstream creation with unspecified I&#x2F;O standard values (not recommended), use this command: set_property SEVERITY {Warning} [get_drc_checks NSTD-1]. NOTE: When using the Vivado Runs infrastructure (e.g. launch_runs Tcl command), add this command to a .tcl file and add that file as a pre-hook for write_bitstream step for the implementation run. Problem ports: BTN_X[4:0], BTN_Y[3], BTN_Y[0], SW[15], SW[14], SW[13], SW[7], SW[6], SW[5], SW[4], SW[3], SW[2], SW[1], SW[0], VGA_B[3:0]… and (the first 15 of 28 listed). 请你帮助可怜的助教解决这个问题😭，完成实验！ 你需要说明： 这个 Error 是出在哪个阶段 (Synthesis&#x2F;Implementation&#x2F;Generate Bitstream) ？ 助教应该怎么做？（请至少给出一种可能的解决方式） 你是通过什么途径了解与解决这个 Error 的？（简单说明即可，参考内容请给出链接） 你不需要理解与说明： 这个错误到底是什么东西，这个错误是怎么产生的。 你可能通过以下途径完成本题： 认真阅读报错信息，说不定解决方案就在 Error 中了？ 使用搜索引擎（最好不要用 Baidu ），粘贴报错的头部，看看能不能借鉴前人的智慧。 善用 Xilinx Support。 感谢你帮助助教完成了实验😊！之后的实验中，如果你发现了各种报错（尤其是 Critical Warnings&#x2F;Errors）也可以先尝试通过今天的途径解决。 这个错误是在 Generate Bitstream 阶段出现的。错误提示表明，在设计中，41个逻辑端口的 I&#x2F;O 标准（IOSTANDARD）使用了默认值 ‘DEFAULT’，而不是用户指定的特定值。这可能导致 I&#x2F;O 冲突或与板卡电源或连接不兼容，影响性能、信号完整性，或在极端情况下导致设备或与其连接的组件损坏。要解决这个问题，需要指定所有 I&#x2F;O 标准。 解决方法： 在 XDC 约束文件中，为每个逻辑端口指定正确的 I&#x2F;O 标准（IOSTANDARD）。例如，对于一个名为 “SW[0]” 的端口，可以添加以下约束： 12cssCopy codeset_property IOSTANDARD LVCMOS33 [get_ports SW[0]] 请根据设计中使用的 FPGA 芯片和开发板，为每个端口选择合适的 I&#x2F;O 标准。 如果允许使用默认的 I&#x2F;O 标准，可以使用以下命令来降低错误的严重性，从而允许生成比特流文件： 12cssCopy codeset_property SEVERITY &#123;Warning&#125; [get_drc_checks NSTD-1] 了解途径： 这个错误是 Vivado 生成的一条 DRC（Design Rule Check，设计规则检查）错误信息。可以从错误提示中获取详细信息，并通过搜索 Xilinx 官方文档中的 “Vivado Design Suite User Guide: I&#x2F;O and Clock Planning (UG899)”。 参考链接： Vivado Design Suite User Guide: I&#x2F;O and Clock Planning (UG899)：https://www.xilinx.com/support/documentation/sw_manuals/xilinx2020_2/ug899-vivado-io-clock-planning.pdf Lab1 &lt;ALU、Regfile 设计和有限状态机&gt; &lt;3200102318&gt; &lt;杨殿超&gt; &#110;&#x6f;&#x69;&#x6e;&#x74;&#x69;&#105;&#105;&#x69;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d; 操作方法与实验步骤一：设计实现数据通路部件 ALU实现ALU（算术逻辑单元），执行给定的操作（通过ALU_operation输入）在两个32位的输入值A和B之间进行计算，并将结果输出到res端口。另外，zero输出端口表示结果是否为零。 实现以下操作： XOR ADD（带进位） AND OR XOR NOR SRL（逻辑右移） M8_1（多路选择器） 在设计方案中，要使用一些中间变量，例如XLXN_1，XLXN_2等，它们用于将ALU_operation输入转换为适当的控制信号以选择要执行的操作。通过这些中间变量，将ALU_operation输入的操作转换为具体的逻辑门电路，从而实现了ALU的功能。 U1模块中的SignalExt_32_0用于从ALU_operation的第3个位中提取一个控制信号，并将其扩展为32位信号。 每个操作都使用单独的模块来实现。 XOR操作使用xor_32_0模块实现，ADD操作使用addc_32_0模块实现，将这些模块连接在一起，并通过中间变量进行通信。最终结果通过M8_1模块进行多路选择，选择正确的结果输出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586module ALU( input [31:0] A, input [31:0] B, input [2:0] ALU_operation, output [31:0] res, output zero);wire XLXN_1 = ALU_operation[2];wire [31:0] XLXN_2;wire [31:0] XLXN_3;wire [32:0] XLXN_4;wire [31:0] XLXN_5 = &#123;31&#x27;b0, XLXN_4[32]&#125;;wire [31:0] XLXN_6;wire [31:0] XLXN_7;wire [31:0] XLXN_8;wire [31:0] XLXN_9;wire [31:0] XLXN_10;SignalExt_32_0 U1( .S(XLXN_1), .So(XLXN_2));xor_32_0 U2( .A(XLXN_2), .B(B), .res(XLXN_3));addc_32_0 U3( .A(A), .B(XLXN_3), .C0(XLXN_1), .S(XLXN_4));and_32_0 U4( .A(A), .B(B), .res(XLXN_6));or_32_0 U5( .A(A), .B(B), .res(XLXN_7));xor_32_0 U6( .A(A), .B(B), .res(XLXN_8));nor_32_0 U7( .A(A), .B(B), .res(XLXN_9));srl32_0 U8( .A(A), .B(B), .res(XLXN_10));M8_1_32_0 U9( .s(ALU_operation), .I0(XLXN_6), .I1(XLXN_7), .I2(XLXN_4[31:0]), .I3(XLXN_8), .I4(XLXN_9), .I5(XLXN_10), .I6(XLXN_4[31:0]), .I7(XLXN_5), .o(res));or_bit_32_0 U10( .A(res), .o(zero));endmodule 二：设计实现数据通路部件 Register Files要实现一个寄存器文件模块，其中包括以下输入和输出： 输入：时钟信号clk、复位信号rst、寄存器写使能信号RegWrite、读取寄存器1的地址Rs1_addr、读取寄存器2的地址Rs2_addr、写入寄存器的地址Wt_addr、写入寄存器的数据Wt_data。 输出：从寄存器1读取的数据Rs1_data、从寄存器2读取的数据Rs2_data以及从寄存器0到寄存器31的所有数据。 该寄存器文件模块主要功能是读取和写入数据到寄存器中。时钟信号clk作为模块输入，控制时序。当复位信号rst为高电平时，寄存器的值被全部初始化为0。当寄存器写使能信号RegWrite为高电平且写入地址Wt_addr不等于0时，寄存器的值被写入新的数据Wt_data。 1234567891011121314151617181920212223242526272829303132333435363738394041424344module regs( input clk, rst, RegWrite, input [4:0] Rs1_addr, Rs2_addr, Wt_addr, input [31:0] Wt_data, output [31:0] Rs1_data, Rs2_data, output [31:0] Reg00, Reg01, Reg02, Reg03, Reg04, Reg05, Reg06, Reg07, Reg08, Reg09, output [31:0] Reg10, Reg11, Reg12, Reg13, Reg14, Reg15, Reg16, Reg17, Reg18, Reg19, output [31:0] Reg20, Reg21, Reg22, Reg23, Reg24, Reg25, Reg26, Reg27, Reg28, Reg29, output [31:0] Reg30, Reg31); reg [31:0] register [1:31]; // r1 - r31，用于存储寄存器的值 integer i; assign Rs1_data = (Rs1_addr == 0) ? 0 : register[Rs1_addr]; // 读取寄存器Rs1_addr的值 assign Rs2_data = (Rs2_addr == 0) ? 0 : register[Rs2_addr]; // 读取寄存器Rs2_addr的值 // 输出各个寄存器的值 assign Reg00 = 0; assign Reg01 = register[1]; assign Reg02 = register[2]; assign Reg03 = register[3]; assign Reg04 = register[4]; assign Reg05 = register[5]; assign Reg06 = register[6]; assign Reg07 = register[7]; assign Reg08 = register[8]; assign Reg09 = register[9]; assign Reg10 = register[10]; assign Reg11 = register[11]; assign Reg12 = register[12]; assign Reg13 = register[13]; assign Reg14 = register[14]; assign Reg15 = register[15]; assign Reg16 = register[16]; assign Reg17 = register[17]; assign Reg18 = register[18]; assign Reg19 = register[19]; assign Reg20 = register[20]; assign Reg21 = register[21]; assign Reg22 = register[22]; assign Reg23 = register[23]; assign Reg24 = register[24]; assign Reg25 = register[25]; assign Reg26 = register[26]; assign Reg27 = register[27]; assign Reg28 = register[28]; assign Reg29 = register[29]; assign Reg30 = register[30]; assign Reg31 = register[31]; always @(posedge clk or posedge rst) begin if (rst == 1) begin for (i = 1; i &lt; 32; i = i + 1) begin register[i] = 0; // 将寄存器的值初始化为0 end end else if ((Wt_addr != 0) &amp;&amp; (RegWrite == 1)) begin register[Wt_addr] = Wt_data; // 将寄存器Wt_addr的值设为Wt_data end endendmodule 三：有限状态机实现首先设计状态转移图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748module seq( input clk, input reset, input in, output out); parameter [2:0] S0=3&#x27;b000, S1=3&#x27;b001, S2=3&#x27;b010, S3=3&#x27;b011, S4=3&#x27;b100, S5=3&#x27;b101, S6=3&#x27;b110, S7=3&#x27;b111; reg [2:0] curr_state; reg [2:0] next_state; // State update always @(posedge clk or negedge reset) begin if (!reset) begin curr_state &lt;= S0; end else begin curr_state &lt;= next_state; end end // State transfer condition always @(curr_state or in) begin case (curr_state) S0: next_state = in ? S1 : S0; S1: next_state = in ? S2 : S0; S2: next_state = in ? S3 : S0; S3: next_state = in ? S0 : S4; S4: next_state = in ? S0 : S5; S5: next_state = in ? S6 : S0; S6: next_state = in ? S0 : S7; S7: next_state = in ? S1 : S0; default: next_state = S0; endcase end // State output assign out = (curr_state == S7) ? 1 : 0;endmodule 实验结果与分析一：ALU仿真首先设计仿真代码： 123456789101112131415161718192021222324252627282930313233343536373839module ALU_TB; reg [31:0] A; reg [31:0] B; reg [2:0] ALU_operation; wire [31:0] res; wire zero; // 实例化ALU模块 ALU ALU_U( .A(A), .B(B), .ALU_operation(ALU_operation), .res(res), .zero(zero) ); initial begin A = 32&#x27;h a5a5a5a5; B = 32&#x27;h 5a5a5a5a; // 分别进行不同的操作并打印结果 ALU_operation = 7; #50; $display(&quot;res = %x, zero = %d&quot;, res, zero); ALU_operation = 6; #50; $display(&quot;res = %x, zero = %d&quot;, res, zero); ALU_operation = 5; #50; $display(&quot;res = %x, zero = %d&quot;, res, zero); ALU_operation = 4; #50; $display(&quot;res = %x, zero = %d&quot;, res, zero); ALU_operation = 3; #50; $display(&quot;res = %x, zero = %d&quot;, res, zero); ALU_operation = 2; #50; $display(&quot;res = %x, zero = %d&quot;, res, zero); ALU_operation = 1; #50; $display(&quot;res = %x, zero = %d&quot;, res, zero); ALU_operation = 0; #50; $display(&quot;res = %x, zero = %d&quot;, res, zero); A = 32&#x27;h0; B = 32&#x27;hFFFFFFFF; // 再次进行不同的操作并打印结果 ALU_operation = 2; #50; $display(&quot;res = %x, zero = %d&quot;, res, zero); ALU_operation = 7; #50; $display(&quot;res = %x, zero = %d&quot;, res, zero); endendmodule $$sltu\\ a5a5a5a5\\ 5a5a5a5a \\ &#x3D; \\ 00000000\\ ;zero&#x3D;1 \\sub\\ a5a5a5a5\\ 5a5a5a5a \\ &#x3D; \\ 4b4b4b4b\\ ;zero&#x3D;0 \\srl\\ a5a5a5a5\\ 5a5a5a5a \\ &#x3D; \\ 00000029\\ ;zero&#x3D;0 \\nor\\ a5a5a5a5\\ 5a5a5a5a \\ &#x3D; \\ 00000000\\ ;zero&#x3D;1 \\xor\\ a5a5a5a5\\ 5a5a5a5a \\ &#x3D; \\ ffffffff\\ ;zero&#x3D;0 \\add\\ a5a5a5a5\\ 5a5a5a5a \\ &#x3D; \\ ffffffff\\ ;zero&#x3D;0 \\or\\ a5a5a5a5\\ 5a5a5a5a \\ &#x3D; \\ ffffffff\\ ;zero&#x3D;0 \\and\\ a5a5a5a5\\ 5a5a5a5a \\ &#x3D; \\ 00000000\\ ;zero&#x3D;1 \\add\\ 00000000\\ ffffffff \\ &#x3D; \\ ffffffff\\ ;zero&#x3D;0 \\sltu\\ 00000000\\ ffffffff \\ &#x3D; \\ 00000001\\ ;zero&#x3D;0$$都符合预期 二、Regfile仿真12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758module Reg_TB; reg clk, rst, RegWrite; reg [4:0] Rs1_addr, Rs2_addr, Wt_addr; reg [31:0] Wt_data; wire [31:0] Rs1_data, Rs2_data; wire [31:0] Reg00, Reg01, Reg02, Reg03, Reg04, Reg05, Reg06, Reg07, Reg08, Reg09; wire [31:0] Reg10, Reg11, Reg12, Reg13, Reg14, Reg15, Reg16, Reg17, Reg18, Reg19; wire [31:0] Reg20, Reg21, Reg22, Reg23, Reg24, Reg25, Reg26, Reg27, Reg28, Reg29; wire [31:0] Reg30, Reg31; // Instantiate the &quot;regs&quot; module with the signals. // &quot;regs&quot; is a Verilog module that contains the logic for register operations. regs regs_U( .clk(clk), .rst(rst), .RegWrite(RegWrite), .Rs1_addr(Rs1_addr), .Rs2_addr(Rs2_addr), .Wt_addr(Wt_addr), .Wt_data(Wt_data), .Rs1_data(Rs1_data), .Rs2_data(Rs2_data), .Reg00(Reg00), .Reg01(Reg01), .Reg02(Reg02), .Reg03(Reg03), .Reg04(Reg04), .Reg05(Reg05), .Reg06(Reg06), .Reg07(Reg07), .Reg08(Reg08), .Reg09(Reg09), .Reg10(Reg10), .Reg11(Reg11), .Reg12(Reg12), .Reg13(Reg13), .Reg14(Reg14), .Reg15(Reg15), .Reg16(Reg16), .Reg17(Reg17), .Reg18(Reg18), .Reg19(Reg19), .Reg20(Reg20), .Reg21(Reg21), .Reg22(Reg22), .Reg23(Reg23), .Reg24(Reg24), .Reg25(Reg25), .Reg26(Reg26), .Reg27(Reg27), .Reg28(Reg28), .Reg29(Reg29), .Reg30(Reg30), .Reg31(Reg31) ); // Initialize the signals. initial begin RegWrite = 0; rst = 1; Rs1_addr = 0; Rs2_addr = 0; Wt_addr = 0; Wt_data[31:0] = 0; #100; rst = 0; RegWrite = 1; Wt_addr[4:0] = 4&#x27;h5; Wt_data[31:0] = 32&#x27;h5a5a5a5a; #50; RegWrite = 1; Wt_addr[4:0] = 4&#x27;hA; Wt_data[31:0] = 32&#x27;h5a5a5a5a; #50; Rs1_addr[4:0] = 4&#x27;h5; #50; Rs2_addr[4:0] = 4&#x27;hA; #50; end // Generate a clock signal. always begin clk = 0; #10; clk = 1; #10; endendmodule 时钟信号：周期性的上升和下降沿。 复位信号：开始时为高，然后在100ns后变为低。 RegWrite信号：在复位后的一段时间内保持高，用于写入操作。然后变为低，用于读取操作。 Wt_addr信号：在写操作期间，该信号将显示所选寄存器的地址。 Wt_data信号：在写操作期间，该信号将显示写入寄存器的数据。 Rs1_addr和Rs2_addr信号：在读操作期间，这两个信号将显示所选寄存器的地址。 Rs1_data和Rs2_data信号：在读操作期间，这两个信号将显示从所选寄存器读取的数据。 符合预期 三：SEQ仿真12345678910111213141516171819202122232425262728293031323334353637383940// Testbench for seq modulemodule seq_TB; reg clk; reg reset; reg in; wire out; // Instantiate seq module seq seq_U( .clk(clk), .reset(reset), .in(in), .out(out) ); // Generate clock signal always #20 clk = ~clk; // Initialize inputs initial begin clk = 0; reset = 0; in = 0; #20 reset = 1; // Assert reset for 20 time units #40 in = 1; #40 in = 1; #40 in = 1; #40 in = 0; #40 in = 0; #40 in = 1; #40 in = 0; #40 in = 1; #40 in = 0; #40 in = 1; // Wait for some time to observe output #100; $finish; // End simulation endendmodule 在仿真开始时，reset信号将保持低电平（0），直到20个时间单位后，reset信号将变为高电平（1），以初始化seq模块的状态。在这个时间点，curr_state将被设置为S0（3’b000）。 in： 在仿真开始的第60个时间单位，in将变为1。这将使状态从S0（3’b000）变为S1（3’b001）。 在第100个时间单位，in仍为1。状态将从S1（3’b001）变为S2（3’b010）。 在第140个时间单位，in仍为1。状态将从S2（3’b010）变为S3（3’b011）。 在第180个时间单位，in变为0。状态将从S3（3’b011）变为S4（3’b100）。 在第220个时间单位，in仍为0。状态将从S4（3’b100）变为S5（3’b101）。 在第260个时间单位，in变为1。状态将从S5（3’b101）变为S6（3’b110）。 在第300个时间单位，in变为0。状态将从S6（3’b110）变为S7（3’b111）。 在第340个时间单位，in变为1。状态将从S7（3’b111）变为S1（3’b001）。 在第380个时间单位，in变为0。状态将从S1（3’b001）变为S0（3’b000）。 在第420个时间单位，in变为1。状态将从S0（3’b000）变为S1（3’b001）。 输出信号out在状态为S7（3’b111）时为1，其他情况下为0。因此，在第300个时间单位到第340个时间单位之间，out信号将变为高电平（1）。在其他时间，out信号将保持低电平（0）。 符合预期 讨论、心得这次实验主要实现 ALU 模块，Regfile 和有限状态机，我对相关内容了解更加深入，这次实验相对较容易，Regfile 和有限状态机在 PPT 中都有代码，只需将错误部分进行修改，并给 Regfile32 个寄存器的线接出来。 思考题1.现在对 ALU 进行拓展，要求修改 ALU 以支持两个有符号数的大小比较，你需要添加哪些端口以支持？（Hint：目前的 ALU 将两个输入都视作无符号数； zero 信号仅能用来判断是否相等） 为了支持两个有符号数的大小比较，我们需要在现有 ALU 的基础上添加一个额外的输出端口，例如 output greater，用于指示 A 是否大于 B。以下是修改后的 ALU module： 1234567891011121314151617181920212223242526module ALU( input [31:0] A, input [31:0] B, input [2:0] ALU_operation, output [31:0] res, output zero, output greater // 添加新的输出端口);// ... wire signed_less; sub_32_0 U11( // 使用 32 位减法器计算 A - B .A(A), .B(B), .S(res_signed_less));assign signed_less = res_signed_less[31]; // 如果 A - B 的结果为负数，则 A 小于 Bassign greater = ~signed_less &amp; ~zero; // 如果 A 不小于 B 且 A 不等于 B，则 A 大于 B// ... endmodule 2.请画出检测序列 1110010 的 Moore 型 FSM 的状态图（你可以使用纸笔清晰画出并拍照，或使用 drawio、FSM Designer 等工具完成制图）。 当前状态 输入 下一个状态 输出 S0 0 S0 0 S0 1 S1 0 S1 0 S0 0 S1 1 S2 0 S2 0 S0 0 S2 1 S3 0 S3 0 S4 0 S3 1 S0 0 S4 0 S5 0 S4 1 S0 0 S5 0 S0 0 S5 1 S6 0 S6 0 S7 0 S6 1 S0 0 S7 0 S0 1 S7 1 S1 1 3.请你修改测试代码，使得给定一个特定输入序列 reg[31:0] input_seq = 32&#39;hD72DBEEF 从高位到低位依次输入到 seq 子模块中。你可以用任何能够使代码更简洁的写法，本题意在考察对 Verilog 语法的熟悉程度。（Hint：如果你没有思路，可以搜索 for loop；还可以用位运算的方式“一次”处理一位） 12345678910111213141516171819202122232425262728293031323334353637module seq_TB; reg clk; reg reset; reg in; wire out; integer i; reg [31:0] input_seq = 32&#x27;hD72DBEEF; // Instantiate seq module seq seq_U( .clk(clk), .reset(reset), .in(in), .out(out) ); // Generate clock signal always #20 clk = ~clk; // Initialize inputs initial begin clk = 0; reset = 0; in = 0; #20 reset = 1; // Assert reset for 20 time units // Apply input_seq to seq module for (i = 31; i &gt;= 0; i = i - 1) begin #40 in = input_seq[i]; end // Wait for some time to observe output #100; $finish; // End simulation endendmodule 波形图如图 Lab2 &lt;IP 核集成 SOC 设计&gt; &lt;3200102318&gt; &lt;杨殿超&gt; &#x6e;&#111;&#x69;&#110;&#116;&#x69;&#x69;&#x69;&#105;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d; 操作方法与实验步骤通过第三方 IP 和已有 IP 模块建立 CPU 测试环境（SOC 系统的集成实现） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210module CSSTE( input clk_100mhz, input RSTN, input [3:0] BTN_y, input [15:0] SW, output [3:0] Blue, output [3:0] Green, output [3:0] Red, output HSYNC, output VSYNC, output LED_PEN, output SEG_PEN, output led_clk, output led_clrn, output led_sout, output seg_clk, output seg_clrn, output seg_sout); // 输入输出信号的定义 wire [31:0] Addr_out; wire [31:0] Data_in; wire [31:0] Data_out; wire MemRW; wire [31:0] PC_out; wire Clk_CPU; wire [31:0] Inst_in; wire rst; wire [9:0] ram_addr; wire [31:0] ram_data_in; wire [31:0] RAM_B_0_douta; wire U4_data_ram_we; wire [3:0] BTN_OK; wire [15:0] SW_OK; wire [15:0] LED_out; wire [31:0] counter_out; wire counter0_OUT; wire counter1_OUT; wire counter2_OUT; //wire [31:0] Cpu_data4bus; wire GPIOf0000000_we; wire GPIOe0000000_we; wire counter_we; wire [31:0] Peripheral_in; wire [7:0] U5_point_out; wire [7:0] U5_LE_out; wire [31:0] Disp_num; wire [31:0] clkdiv; wire [1:0] counter_set; wire STEP=SW_OK[10]|BTN_OK[0]; // 模块实例化 SCPU U1( .Addr_out(Addr_out), .Data_in(Data_in), .Data_out(Data_out), .MemRW(MemRW), .PC_out(PC_out), .clk(Clk_CPU), .inst_in(Inst_in), .rst(rst) ); Rom_D_0 U2( .a(PC_out[11:2]), .spo(Inst_in) ); RAM U3( .addra(ram_addr), .clka(~clk_100mhz), .dina(ram_data_in), .douta(RAM_B_0_douta), .wea(U4_data_ram_we) ); MIO_BUS U4( .clk(clk_100mhz), .rst(rst), .BTN(BTN_OK), .SW(SW_OK), .mem_w(MemRW), .Cpu_data2bus(Data_out), .addr_bus(Addr_out), .ram_data_out(RAM_B_0_douta), .led_out(LED_out), .counter_out(counter_out), .counter0_out(counter0_OUT), .counter1_out(counter1_OUT), .counter2_out(counter2_OUT), .Cpu_data4bus(Data_in), .ram_data_in(ram_data_in), .ram_addr(ram_addr), .data_ram_we(U4_data_ram_we), .GPIOf0000000_we(GPIOf0000000_we), .GPIOe0000000_we(GPIOe0000000_we), .counter_we(counter_we), .Peripheral_in(Peripheral_in) ); Multi_8CH32 U5( .clk(~Clk_CPU), .rst(rst), .EN(GPIOe0000000_we), .Test(SW_OK[7:5]), .point_in(&#123;clkdiv[31:0], clkdiv[31:0]&#125;), .LES(64&#x27;b0), .Data0(Peripheral_in), .data1(&#123;2&#x27;b0, PC_out[31:2]&#125;), .data2(Inst_in), .data3(counter_out), .data4(Addr_out), .data5(Data_out), .data6(Data_in), .data7(PC_out), .point_out(U5_point_out), .LE_out(U5_LE_out), .Disp_num(Disp_num) ); SSeg7_Dev_0 U6( .clk(clk_100mhz), .flash(clkdiv[25]), .Hexs(Disp_num), .LES(U5_LE_out), .point(U5_point_out), .rst(rst), .Start(clkdiv[20]), .SW0(SW_OK[0]), .seg_clk(seg_clk), .seg_clrn(seg_clrn), .SEG_PEN(SEG_PEN), .seg_sout(seg_sout) ); SPIO U7( .clk(~Clk_CPU), .rst(rst), .Start(clkdiv[20]), .EN(GPIOf0000000_we), .P_Data(Peripheral_in), .counter_set(counter_set), .LED_out(LED_out), .led_clk(led_clk), .led_sout(led_sout), .led_clrn(led_clrn), .LED_PEN(LED_PEN) ); clk_div U8( .clk(clk_100mhz), .rst(rst), .SW2(SW_OK[2]), .SW8(SW_OK[8]), .STEP(STEP), .clkdiv(clkdiv), .Clk_CPU(Clk_CPU) ); SAnti_jitter U9( .clk(clk_100mhz), .RSTN(RSTN), //.readn(readn), .Key_y(BTN_y), .SW(SW), //.Key_x(Key_x), //.Key_out(Key_out), //.Key_ready(Key_ready), //.pulse_out(pulse_out), .BTN_OK(BTN_OK), .SW_OK(SW_OK), //.CR(CR), .rst(rst) ); Counter_x U10( .clk(~Clk_CPU), .rst(rst), .clk0(clkdiv[6]), .clk1(clkdiv[9]), .clk2(clkdiv[11]), .counter_we(counter_we), .counter_val(Peripheral_in), .counter_ch(counter_set), .counter0_OUT(counter0_OUT), .counter1_OUT(counter1_OUT), .counter2_OUT(counter2_OUT), .counter_out(counter_out) ); VGA U11 ( .clk_25m(clkdiv[1]), .clk_100m(clk_100mhz), .rst(rst), .pc(PC_out), .inst(Inst_in), .alu_res(Addr_out), .mem_wen(MemRW), .dmem_o_data(RAM_B_0_douta), .dmem_i_data(ram_data_in), .dmem_addr(Addr_out), .hs(HSYNC), .vs(VSYNC), .vga_r(Red), .vga_g(Green), .vga_b(Blue));endmodule 添加源文件 clk_div.v 12345678910111213141516171819module clk_div( input clk, input rst, input SW2,SW8,STEP, output reg [31:0]clkdiv, // 32 位计数分频输出 output Clk_CPU); always @ (posedge clk or posedge rst) begin if (rst) clkdiv &lt;= 0; else clkdiv &lt;= clkdiv + 1&#x27;b1; end assign Clk_CPU = (SW8 == 1) ? STEP : (SW2 == 1) ? clkdiv[24] : clkdiv[2]; endmodule 根据要求，需要修改 VGA.v 模块，以便将其他调试信号接入到 VGA 模块并在屏幕上显示。 首先，需要在 VGA.v 的端口描述中添加调试信号输入。 12345input wire [31:0] rs1,input wire [31:0] rs1_val,input wire [31:0] rs2,input wire [31:0] rs2_val,//... 接下来，将这些新添加的端口连接到 VgaDebugger 实例： 12345678VgaDebugger vga_debugger( // ... .rs1(rs1), .rs1_val(rs1_val), .rs2(rs2), .rs2_val(rs2_val), //... ); 实验结果与分析SW[8]置高 第一条指令： SW[7:5] ：001 010 100 101 110 111 第二条指令： SW[7:5] ：001 010 100 101 110 111 第三条指令： SW[7:5] ：001 010 100 101 110 111 res变化符合斐波那契数列： 讨论、心得这次实验通过实现CSSTE硬件描述、clk_div模块，调用文件夹中给的IP，搭建了一个CPU，接下来就是准备冲刺单周期！ Lab3 &lt;复杂操作实现&gt; &lt;3200102318&gt; &lt;杨殿超&gt; &#x6e;&#111;&#105;&#110;&#116;&#105;&#x69;&#x69;&#x69;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d; 操作方法与实验步骤一：乘法器采用Booth算法进行有符号整数乘法 输入： clk：时钟信号，用于同步电路 rst：复位信号，用于初始化电路状态 multiplicand：32位被乘数 multiplier：32位乘数 start：开始信号，用于启动乘法操作 输出： product：64位输出结果，存放乘法运算的结果 finish：完成信号，表示乘法运算完成 使用有限状态机（FSM），包含四个状态：IDLE（空闲）、ADD（加法）、SHIFT（移位）和OUTPUT（输出）。 主要步骤： 初始化状态：在复位信号rst为0时，当前状态curr_state设置为IDLE（空闲）状态。 状态转移：根据当前状态，确定下一个状态next_state。例如，在IDLE状态下，如果计数器ct小于31，则进入ADD状态；否则，保持在IDLE状态。 计数器和完成信号的初始化：在启动信号start为1时，将计数器ct重置为0，完成信号finish置0。 实现Booth算法：根据当前状态执行Booth算法的操作。在IDLE状态下，初始化乘积寄存器product。在ADD状态下，根据product的最低位和booth_temp的值执行加法或减法操作。在SHIFT状态下，执行算术右移操作，并更新计数器ct。在OUTPUT状态下，将完成信号finish置1，表示乘法操作完成。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172module mul32( input clk, input rst, input [31:0] multiplicand, input [31:0] multiplier, input start, output reg [63:0] product, output reg finish);parameter [1:0] IDLE=2&#x27;b00, ADD=2&#x27;b01, SHIFT=2&#x27;b10, OUTPUT=2&#x27;b11;reg [1:0] curr_state;reg [1:0] next_state;reg [63:0] temp;reg [6:0] ct;reg booth_temp;//state transferalways @(posedge clk or negedge rst)begin if(!rst) curr_state &lt;= IDLE; else curr_state &lt;= next_state;end//transfer conditionalways @(*)begin case (curr_state) IDLE : if(ct&lt;31) next_state &lt;= ADD; else next_state &lt;= IDLE; ADD : next_state &lt;= SHIFT; SHIFT : if(ct==31) next_state &lt;= OUTPUT; else next_state &lt;= ADD; OUTPUT: next_state &lt;= IDLE; endcaseendalways @(posedge start) begin ct &lt;= 0; finish &lt;= 0;end//Booth algorithmalways @(posedge clk or negedge rst) begin case (curr_state) IDLE: begin if(finish==0) begin product[31:0] &lt;= multiplier; product[63:32] &lt;= 0; end booth_temp &lt;= 0; end ADD: begin case (&#123;product[0], booth_temp&#125;) 2&#x27;b01 : product[63:32] &lt;= product[63:32] + multiplicand; 2&#x27;b10 : product[63:32] &lt;= product[63:32] - multiplicand; 2&#x27;b00,2&#x27;b11 : ; endcase end SHIFT: begin booth_temp &lt;= product[0]; product &lt;= ($signed(product) &gt;&gt;&gt; 1); ct &lt;= ct+1; end OUTPUT : begin finish &lt;= 1; end endcaseendendmodule 二：除法器实现32位有符号除法 输入包括时钟信号（clk）、复位信号（rst）、开始信号（start）、被除数（dividend）和除数（divisor） 输号包括计算完成信号（finish）、商（quotient）、余数（remainder）和除数为零的情况（divide_zero）。 首先，定义一组参数（IDLE、SUB、SHIFT、OUTPUT）作为状态机的状态。在这个状态机中，IDLE表示空闲状态，SUB表示减法状态，SHIFT表示移位状态，OUTPUT表示输出状态。 然后定义一组寄存器用于存储各种中间值，如下： curr_state 和 next_state 用于存储状态机的当前状态和下一状态。 divisor_abs 用于存储除数的绝对值。 dividend_is_neg 和 divisor_is_neg 用于标记被除数和除数是否为负数。 state 用于存储状态的临时值。 ct 是计数器，用于计算已执行的操作数。 quotient_to_remainder 用于在 SHIFT 状态时从商的最高位传递到余数的最低位。 quotient_bit 用于在 SUB 状态时确定当前商的位值。 主要逻辑部分包括状态转换和除法计算。 状态转换：在每个时钟上升沿或复位信号下降沿，当前状态将根据下一状态进行更新。 转换条件：根据当前状态确定下一状态。 初始化：当开始信号上升时，初始化计数器、完成信号、除数为零情况以及被除数和除数的正负标志。 除法计算：在每个时钟上升沿或复位信号下降沿进行除法计算。根据当前状态执行不同的操作，主要包括以下步骤： IDLE：空闲状态，初始化商、余数和除数的绝对值。检查除数是否为零，若为零，设置除零信号。 SUB：减法状态，用当前余数减去除数的绝对值，若结果为负，则将除数的绝对值加回余数，并设置当前商位为0；否则设置当前商位为1。更新计数器和状态。 SHIFT：移位状态，将商和余数左移一位，将商的最高位传递给余数的最低位，并将当前商位值设置为quotient_bit。更新状态。 OUTPUT：输出状态，根据被除数和除数的正负标志调整商和余数的符号，设置完成信号。更新状态。 当状态机完成32次迭代并到达输出状态时，输出商（quotient）和余数（remainder），以及完成信号（finish）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116module div32( input clk, input rst, input start, input [31:0] dividend, input [31:0] divisor, output reg finish, output reg [31:0] quotient, output reg [31:0] remainder, output reg divide_zero); parameter [1:0] IDLE=2&#x27;b00, SUB=2&#x27;b01, SHIFT=2&#x27;b10, OUTPUT=2&#x27;b11; reg [1:0] curr_state; reg [1:0] next_state; reg [31:0] divisor_abs; reg dividend_is_neg; reg divisor_is_neg; reg [1:0] state; reg [6:0] ct; reg quotient_to_remainder; reg quotient_bit; //state transfer always @(posedge clk or negedge rst) begin if(rst) curr_state &lt;= IDLE; else curr_state &lt;= next_state; end //transfer condition always @(*) begin case (curr_state) IDLE : if(ct&lt;31) next_state &lt;= SHIFT; else next_state &lt;= IDLE; SUB : next_state &lt;= SHIFT; SHIFT : if(ct==32) next_state &lt;= OUTPUT; else next_state &lt;= SUB; OUTPUT: next_state &lt;= IDLE; endcase end always @(posedge start) begin ct &lt;= 0; finish &lt;= 0; divide_zero &lt;= 0; // Initialize divide_zero dividend_is_neg &lt;= 0; divisor_is_neg &lt;= 0; end //divide v3 always @(posedge clk or negedge rst) begin case (curr_state) IDLE: begin if(finish==0) begin quotient[31:0] &lt;= dividend; if(dividend[31]==1) begin quotient[31:0] &lt;= -dividend; dividend_is_neg=1; end remainder[31:0] &lt;= 0; divisor_abs &lt;= divisor; if(divisor[31]==1) begin divisor_abs &lt;= -divisor; divisor_is_neg=1; end // Check for divide by zero if (divisor == 0) begin finish &lt;= 1; divide_zero &lt;= 1; quotient &lt;= 32&#x27;b0; remainder &lt;= 32&#x27;b0; end end quotient_bit = 0; state &lt;= 2&#x27;b00; end SUB: begin remainder[31:0] = remainder[31:0]-divisor_abs; quotient_bit = 1; if(remainder[31]==1) begin remainder[31:0] = remainder[31:0]+divisor_abs; quotient_bit = 0; end ct = ct+1; state = 2&#x27;b01; end SHIFT: begin quotient_to_remainder = quotient[31]; remainder = remainder &lt;&lt; 1; remainder[0]=quotient_to_remainder; quotient = quotient &lt;&lt; 1; quotient[0] = quotient_bit; state = 2&#x27;b10; end OUTPUT : begin remainder = ($signed(remainder) &gt;&gt;&gt; 1); case (&#123;dividend_is_neg, divisor_is_neg&#125;) 2&#x27;b01 : quotient = -quotient; 2&#x27;b10 : begin quotient = -quotient; remainder = -remainder; end 2&#x27;b11 : remainder = -remainder; 2&#x27;b00 : ; endcase finish = 1; state = 2&#x27;b11; end endcase end endmodule 三：浮点加减法 32 位浮点数加法器,根据控制信号 c，模块可以执行加法或减法。模块还有一个使能信号 en，当 en &#x3D; 1 时，模块开始运行。当计算完成时，模块将计算结果存储在 32 位寄存器 result 中，并将输出信号 fin 置为 1。 该模块采用有限状态机（FSM）的设计方法，包括五个状态：IDLE（空闲）、ADD（加法&#x2F;减法）、NORMALIZE（规格化）、ROUND（舍入）和 OUTPUT（输出）。状态之间的转换是由时钟信号 clk 和复位信号 rst 控制的。 定义输入、输出和参数：模块接收时钟信号 clk、复位信号 rst、两个 32 位浮点数输入 A 和 B、2 位控制信号 c 和使能信号 en。输出包括 32 位寄存器 result 和一个表示计算完成的信号 fin。 定义状态变量：curr_state、next_state、state 用于表示 FSM 的状态，exp、exp_dif 用于表示指数和指数差，m、m0、m1 用于表示尾数及其中间结果，neg 用于表示结果的符号。 状态转换逻辑：这部分代码描述了如何根据时钟和复位信号更新当前状态。在每个时钟上升沿，当前状态 curr_state 将更新为 next_state；在复位信号下降沿，当前状态将重置为 IDLE。 状态转换条件：这部分代码描述了在当前状态下如何确定下一个状态。例如，在 IDLE 状态下，如果计算尚未完成（fin 不为 1），则进入 ADD 状态。 初始化逻辑：在输入 A 或 B 改变时，将 fin 置为 0、neg 置为 0，result 清零。 浮点数加法逻辑：这部分代码实现了 FSM 的具体操作，包括加法&#x2F;减法、规格化、舍入和输出结果。在 ADD 状态下，计算指数差、更新尾数 m0 和 m1；在 NORMALIZE 状态下，规格化结果尾数 m；在 ROUND 状态下，进行舍入（本例中没有实际舍入操作）；在 OUTPUT 状态下，将计算结果存储到 result 寄存器并设置 fin 信号为 1。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106module float_add_32( input clk, input rst, input [31:0] A, input [31:0] B, input [1:0] c, // 00 +, 01 -, 10 *, 11 / input en, // en = 1, begin output reg [31:0] result, output reg fin // fin = 1 when finish);parameter [2:0] IDLE=3&#x27;b000, ADD=3&#x27;b001, NORMALIZE=3&#x27;b010, ROUND=3&#x27;b011, OUTPUT=3&#x27;b100;reg [2:0] curr_state;reg [2:0] next_state;reg [2:0] state;reg [7:0] exp;reg [7:0] exp_dif;reg [25:0] m;reg [25:0] m0;reg [25:0] m1;reg neg;//state transferalways @(posedge clk or negedge rst) begin if(rst) curr_state &lt;= IDLE; else curr_state &lt;= next_state;end//transfer conditionalways @(*) begin case (curr_state) IDLE : if(!fin) next_state &lt;= ADD; else next_state &lt;= IDLE; ADD : next_state &lt;= NORMALIZE; NORMALIZE : next_state &lt;= ROUND; ROUND: next_state &lt;= OUTPUT; OUTPUT: next_state &lt;= IDLE; endcaseendalways @(A or B) begin fin &lt;= 0; neg &lt;= 0; result &lt;= 0;end//float_addalways @(posedge clk or negedge rst) begin case (curr_state) IDLE: begin state &lt;= 3&#x27;b000; end ADD: begin exp_dif = A[30:23] - B[30:23]; if(exp_dif[7]==0) begin exp = A[30:23]; m1 = &#123;3&#x27;b001, B[22:0]&#125;; m1 = m1 &gt;&gt; exp_dif; m0 = &#123;3&#x27;b001, A[22:0]&#125;; end else begin exp = B[30:23]; m0 = &#123;3&#x27;b001, A[22:0]&#125;; m0 = m0 &gt;&gt; exp_dif; m1 = &#123;3&#x27;b001, B[22:0]&#125;; end if(A[31]==1) m0 = -m0; if(B[31]==1) m1 = -m1; case(c) 2&#x27;b00: m = m0 + m1; 2&#x27;b01: m = m0 - m1; 2&#x27;b10, 2&#x27;b11: ; endcase state &lt;= 3&#x27;b001; end NORMALIZE: begin if(m[25]==1) begin m = ~m + 1; neg = 1; end if(m[24]==1) begin m = m &gt;&gt; 1; exp = exp + 1; end while(m[23]==0) begin m = m &lt;&lt; 1; exp = exp - 1; end state &lt;= 3&#x27;b010; end ROUND: begin state &lt;= 3&#x27;b011; end OUTPUT : begin result &lt;= &#123;neg, exp, m[22:0]&#125;; fin &lt;= 1; state &lt;= 3&#x27;b100; end endcaseendendmodule 实验结果与分析一：乘法器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364module mul32_tb(); reg clk; reg rst; reg [31:0] multiplicand; reg [31:0] multiplier; reg start; wire [63:0] product; wire finish; // Test case array reg [31:0] test_case_multiplicand [0:4]; reg [31:0] test_case_multiplier [0:4]; integer i; initial begin // Initialize test cases test_case_multiplicand[0] = 32&#x27;hfffffffe; test_case_multiplier[0] = 32&#x27;d2; test_case_multiplicand[1] = 32&#x27;d5; test_case_multiplier[1] = 32&#x27;d7; test_case_multiplicand[2] = 32&#x27;d8; test_case_multiplier[2] = 32&#x27;d8; test_case_multiplicand[3] = 32&#x27;d50; test_case_multiplier[3] = 32&#x27;d6; test_case_multiplicand[4] = 32&#x27;d6; test_case_multiplier[4] = 32&#x27;d60; // Initial settings clk = 0; rst = 0; multiplicand = 0; multiplier = 0; start = 0; #50 rst = 1; // Run test cases for (i = 0; i &lt; 5; i = i + 1) begin start = 1; multiplicand = test_case_multiplicand[i]; multiplier = test_case_multiplier[i]; #150 start = 0; // Wait for finish signal while(!finish) begin #10; end #150; end #100 $finish(); end always #0.5 clk = ~clk; mul32 mul32_u( clk, rst, multiplicand, multiplier, start, product, finish );endmodule $$-2*(-2)&#x3D;4\\57&#x3D;35\\88&#x3D;64\\506&#x3D;300\\660&#x3D;360$$符合有符号乘法器 二：除法器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960module div32_tb(); reg clk; reg rst; reg [31:0] dividend; reg [31:0] divisor; reg start; wire divide_zero; wire [31:0] quotient; wire [31:0] remainder; wire finish; div32 u_div( .clk(clk), .rst(rst), .dividend(dividend), .divisor(divisor), .start(start), .quotient(quotient), .remainder(remainder), .finish(finish), .divide_zero(divide_zero) ); always #1 clk = ~clk; initial begin clk = 0; rst = 1; start = 0; dividend = 32&#x27;d0; divisor = 32&#x27;d0; #10 rst = 0; start = 1; dividend = -2; divisor = 1; #150 start = 0; #50 start = 1; dividend = 32&#x27;d100; divisor = 32&#x27;d10; #150 start = 0; #50 start = 1; dividend = 9; divisor = 0; #150 start = 0; #50 start = 1; dividend = -100; divisor = -56; #350 start = 0; #350 $stop(); endendmodule !$$-2&#x2F;1&#x3D;-2\\100&#x2F;10&#x3D;10\\9&#x2F;0时将finish和divide_zero置高\\-100&#x2F;-56&#x3D;1······-44$$符合有符号除法器，且实现了除零异常 三：浮点加减法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364module float_add_32_tb;// Inputsreg clk;reg rst;reg [31:0] A;reg [31:0] B;reg [1:0] c;reg en;// Outputswire [31:0] result;wire fin;// Instantiate the Unit Under Test (UUT)float_add_32 add ( .clk(clk), .rst(rst), .A(A), .B(B), .c(c), .en(en), .result(result), .fin(fin));always #5 clk = ~clk;initial begin // Initialize Inputs clk = 0; rst = 1; A = 32&#x27;hc0000000; B = 32&#x27;hc0000000; c = 2&#x27;b00; en = 0; #20; rst = 0; A = 32&#x27;hc0a00002; B = 32&#x27;hc0900000; c = 2&#x27;b00; en = 1; #180; A = 32&#x27;h40a00000; B = 32&#x27;h40900000; en = 1; #180; #80; c=2&#x27;b01; A = 32&#x27;h40a24800; B = 32&#x27;h40d74523; en = 1; #180 A = 32&#x27;h40a00000; B = 32&#x27;h40900000; en = 1; #180; en = 0;endendmodule $$-5.0+(-4.5)&#x3D;-9.5\\5.0+4.5&#x3D;9.5\\5.1-6.7&#x3D;-1.6\\5.0-4.5&#x3D;0.5$$ 讨论、心得浮点数的运算还是很有意思的，运算的顺序都能导致天差地别！说到底都是精度的锅！ 思考题请结合理论课所学，回答以下问题： 双精度浮点数 x,y,z，若 1x = -1.5e38, y = 1.5e38, z=1.0 (x+y)+z = ?； x+(y+z) = ?； 两者有区别吗？请解释你的回答。 假设使用单精度浮点数，编写以下代码 1234float x = SOME_VALUE_0;float sum = 0.0f;for(int i = 0; i &lt; SOME_VALUE_1; ++i) sum += x;printf(&quot;%f\\n&quot;, sum - 100.0f); 如果 SOME_VALUE_0 := 0.1, SOME_VALUE_1 := 1000，你将得到什么结果？ 如果 SOME_VALUE_0 := 0.125, SOME_VALUE_1 := 800，你将得到什么结果？ 请结合浮点数定义，解释两者差异。 （1） (x+y)+z &#x3D; 1.0 首先计算 x+y，由于 x 和 y 的绝对值相等，但符号相反，因此它们相加得到 0。接下来将结果与 z 相加，得到： (x+y)+z &#x3D; 0 + 1.0 &#x3D; 1.0 （2）x+(y+z) &#x3D; 0 首先计算 y+z，结果为： y+z &#x3D; 1.5e38 + 1.0 ≈ 1.5e38 然后将 x 与这个结果相加，得到： x+(y+z) &#x3D; -1.5e38 + 1.5e38 &#x3D; 0 （3）有区别，解释： 两个计算的结果是不同的。这是因为浮点数运算存在舍入误差。在第一个计算中，x 和 y 相加得到的结果正好为 0，因此不存在舍入误差。但在第二个计算中，y 和 z 相加时会发生舍入误差，由于 z 的数值远小于 y 的数值，z 在相加时对 y 几乎没有影响，因此 y+z 的结果仍接近 1.5e38。当 x 与该结果相加时，同样由于舍入误差，计算结果为 0 而不是 1。 （1） 若 SOME_VALUE_0 := 0.1, SOME_VALUE_1 := 1000： 由于单精度浮点数不能精确表示 0.1，实际存储的值会有微小的差异。当将这个近似值加 1000 次后，累积的误差会放大。因此，最终的结果将不会精确地等于 100.0。假设结果接近 100.0。 （2） 若 SOME_VALUE_0 := 0.125, SOME_VALUE_1 := 800： 由于单精度浮点数可以精确表示 0.125（因为它是 2 的负整数次幂），计算过程中不会产生舍入误差。因此，最终的结果将精确地等于 100.0。 （3）解释两者差异： 这两个例子之间的差异在于浮点数表示的精确性。在第一个例子中，0.1 不能被单精度浮点数精确表示，因此计算过程中会产生舍入误差。而在第二个例子中，0.125 可以被单精度浮点数精确表示，因此计算过程中不会产生舍入误差。","categories":[],"tags":[]}],"categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/categories/Computer-Science/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/categories/Machine-Learning/"},{"name":"Computer Organization and Design","slug":"Computer-Science/Computer-Organization-and-Design","permalink":"http://noint.top/categories/Computer-Science/Computer-Organization-and-Design/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://noint.top/tags/Computer-Science/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://noint.top/tags/Machine-Learning/"}]}